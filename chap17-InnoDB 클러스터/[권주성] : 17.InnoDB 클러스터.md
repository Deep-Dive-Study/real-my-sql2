# 17 InnoDB 클러스터
- MySQL 서버 자체적으로 페일오버를 처리하는 기능을 제공하지 않았으므로 사용자는 MySQL의 복제 기능을 사용해 서비스의 고가용성을 실현할 수 있지만 단순히 현재 사용중인 MySQL 서버들을 소스-레플리카 구조의 복제 형태로 구성해놓는다고 해서 고가용성이 실현되는 것은 아니었음

- 기존에는 서버 장애를 감지해 자동으로 페일오버 처리하는 프로그램을 직접 개발하거나 서드 파티 HA 솔루션을 사용했는데 MySQL 5.7.17 버전에서 빌트인 형태의 HA 솔루션인 InnoDB 클러스터가 도입되면서 사용자는 좀 더 쉽고 편리하게 고가용성을 실현할 수 있게 됨

- InnoDB 클러스터는 MySQL 8.0 이후에도 계속 신규 기능들이 들어오고 있고 버전별로 많은 기능의 차이를 보임
  - InnoDB 클러스터를 사용한다면 가능한 한 최신 버전의 MySQL 서버를 사용할 것을 권장

## 17.1 InnoDB 클러스터 아키텍처
- InnoDB 클러스터는 단순하게 MySQL 서버 내에서 설정할 수 있는 어떤 특정한 기능이 아닌 MySQL의 고가용성 실현을 위해 만들어진 여러 구성 요소들의 집합체
  
- `InnoDB 클러스터를 구성하는 요소`

  ![CleanShot 2024-02-03 at 15 44 24](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/7e188d0e-555a-4398-aa1d-18d31f88e8bf)

  ![CleanShot 2024-02-03 at 15 44 06](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/8f28081a-dc49-4fa1-b019-efbaccd4d99d)

- InnoDB 클러스터에서 데이터가 저장되는 MySQL 서버들은 그룹 복제 형태로 복제가 구성되며 각 서버는 읽기/쓰기가 모두 가능한 프라이머리 혹은 읽기만 가능한 세컨더리중 하나의 역할로 동작하게 됨
  
- 그룹 복제에서는 InnoDB 스토리지 엔진만 사용될 수 있는데 이것이 바로 InnoDB 클러스터라고 명명된 이유라 할 수 있음
  
- 그룹 복제를 구성할 때 고가용성을 위해 MySQL 서버를 최소 3대 이상으로 구성해야 함. 그래야 MySQL 서버 한 대에 장애가 발생하더라도 복제 그룹이 정상적으로 동작하기 때문
  
- InnoDB 클러스터를 사용하는 환경에서 클라이언트는 MySQL 서버로 직접 접근해서 쿼리를 실행하는 것이 아니라 MySQL 라우터에 연결해서 쿼리를 실행함
  
- MySQL 라우터는 InnoDB 클러스터로 구성된 MySQL 서버들에 대한 메타데이터 정보를 지니며 이를 바탕으로 클라이언트로부터 실행된 쿼리를 클러스터 내 적절한 MySQL 서버로 전달함
  - 따라서 클라이언트는 현재 InnoDB 클러스터가 어떤 서버로 구성돼 있는지 알고 있을 필요가 없고 커넥션 정보에는 MySQL 라우터 서버만 설정해두면 됨

- MySQL 셸은 사용자가 손쉽게 InnoDB 클러스터를 생성하고 관리할 수 있도록 API를 제공하는 등의 여러가지 기능을 제공
  
- InnoDB 클러스터에서는 MySQL 서버에 장애가 발생하면 그룹 복제가 먼저 이를 감지해서 자동으로 해당 서버를 복제 그룹에서 제외시키며 MySQL 라우터는 이러한 복제 토폴로지 변경을 인지하고 자신이 가진 메타데이터를 갱신해서 클라이언트로부터 실행된 쿼리가 현재 복제 그룹에 정상적으로 동작하는 MySQL 서버로만 전달될 수 있음

- 즉 기존에는 전부 수동으로 장애 복구 처리를 해야 했던 부분들이 InnoDB 클러스터에서는 모두 자동으로 처리됨

## 17.2 그룹 복제 (Group Replication)
- 그룹복제는 MySQL 5.7.17 버전에서 도입된 새로운 복제 방식이고 기존 MySQL 복제 프레임워크를 기반으로 구현되어 내부적으로 Row 포맷의 바이너리로그와 릴레이 로그, GTID를 사용

- 이처럼 기존 MySQL 복제와 구조적으로 유사한 부분도 있지만 복제 구성 형태, 트랜잭션 처리 방식 측면에서는 완전히 다른 복제 방식

- 기존 복제의 경우 일반적으로 소스-레플리카 형태로 구성되어 단방향 복제인 반면 그룹 복제에서는 복제에 참여하는 MYSQL 서버들이 하나의 복제 그룹으로 묶인 클러스터 형태를 가지며 그룹 내 서버들은 서로 통신하는 양방향 복제처리를 할 수 있음
  - 하나의 복제 그룹에서 쓰기 처리하는 서버가 2대 이상일 수 있음

- 따라서 복제 그룹에서 소스-레플리카라는 용어는 사용하지 않고 프라이머리, 세컨더리라는 용어로 사용

- 프라이머리는 쓰기 전용, 세컨더리는 읽기 전용, 그룹복제에 참여하는 MySQL 서버들은 그룹멤버 라고 지칭

- 그룹 복제는 기존 복제와 복제 처리 방식에서도 큰 차이를 보임

`복제 방식`

![CleanShot 2024-02-03 at 15 51 09](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/b4667d4b-4d6d-4277-b3d1-49aca671b9c7)

![CleanShot 2024-02-03 at 15 51 28](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/69574365-3cb3-403c-bd8d-4711e0458df5)

- 기존 복제에서는 기본적으로 소스 서버에서의 트랜잭션 커밋 처리가 레플리카 서버와는 무관하게 처리되는 비동기 방식으로 동작
  - 소스서버에서는 트랜잭션 커밋 시 레플리카 서버로도 해당 트랜잭션이 잘 전달 됐는지 확인하지 않음

- 반동기 방식은 트랜잭션 처리를 할 때 소스 서버와 레플리카 사이에 확인 단계가 하나 추가된 것으로 반동기방식을 사용하는 경우 소스 서버에서는 트랜잭션 커밋 처리 중 레플리카 서버로 트랜잭션이 잘 전달됐는지 응답을 기다린 후 최정적으로 커밋을 함

- 그룹 복제에서는 한 서버에서 트랜잭션이 커밋될 준비가 되면 트랜잭션 정보를 그룹의 다른 멤버들에게 전송하고 과반수 이상의 멤버로부터 응답을 전달받으면 그때 해당 트랜잭션을 인증하고 최종적으로 커밋 처리를 완료

- 트랜잭션 인증은 인증 대상 트랜잭션이 이미 인증 단계를 통과한 선행 트랜잭션과 동시점에 동일한 데이터를 변경했는지 충돌 여부를 검사해서 문제 없이 적용 가능하지를 확인하는 과정

- 그룹 복제에서 트랜잭션 커밋을 처리할 때 만약 과반수 이상의 멤버로부터 응답을 받지 못하면 해당 트랜잭션은 그룹에 적용되지 않음

- 가장 큰 차이점으로는 비동기, 반동기 방식 모두 복제 구성 내에서 트랜잭션은 소스 서버에서 일방적으로 적용되지만 그룹 복제에서는 그룹 내 멤버들의 응답에 따라 전체 복제 그룹에서 해당 트랜잭션의 적용 여부가 결정된다는 것

- 그룹 복제에서 이처럼 트랜잭션 커밋을 처리할 때 그룹의 다른 멤버들에 대한 응답을 확인하는 과정을 `합의 Consensus` 라고 한다.

- 그룹 복제는 기존 복제 환경에서 수동처리되어야 하는 부분을 자동화된 기능으로 제공함으로써 사용자의 편의성을 증대함

- `그룹 복제에서 제공하는 대표적인 기능`
  - 그룹 멤버 관리
  - 그룹 단위의 정렬된 트랜잭션 적용 및 트랜잭션 충돌 감지
  - 자동 페일오버
  - 자동 분산 복구
    
### 17.2.1 그룹 복제 아키텍처

- 그룹 복제는 별도 플러그인으로 구현돼 있고 그룹 복제를 사용하기 위해서는 MySQL 서버에 그룹 복제 플러그인이 설치 되어야 함

![CleanShot 2024-02-03 at 15 50 32](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/97c495e6-98db-4721-b1c6-5aff726ea48f)

- 그룹 복제에 참여하는 MySQL 서버들은 그룹 복제 플로그인을 통해 서로 간에 지속적으로 통신하며 복제 동기화 처리함

- 그룹 복제 플러그인은 MySQL 서버에 그룹 복제가 설정되면 `group_replication_applier` 라는 복제 채널을 생성해서 이 채널로 모든 트랜잭션을 전달받아 적용하게 됨

- 그룹 복제 분산 복구 작업이 필요한 경우 `group_replication_recovery` 라는 복제 채널을 생성해서 분산 복구 작업을 진행

- `그룹 복제 플러그인의 내부 구조`

  ![CleanShot 2024-02-03 at 15 52 27](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/4cad51d2-de9f-4d5b-95dc-669d1a05f368)

  - `Plugin API 계층`
    
    - 플러그인 최상위 계층에는 그룹 복제 플러그인이 MySQL 서버와 상호작용 하기 위해 구현된 인터페이스인 플러그인 API 집합이 존재함
    - 플러그인 API를 통해 MySQL 서버에는 MySQL 서버의 시작 또는 복구, 트랜잭션 커밋 등의 이벤트를 그룹 복제 플러그인에 전달하고 그룹 복제 플러그인에서는 처리중인 트랜잭션에 대한 커밋 또는 중단, 릴레이 로그 기록을 위한 요청 등을 서버에 전달
    
  - `Replication Plugin 계층`
    
    - 그 다음 계층으로 그룹 복제의 기능들이 실질적으로 구현돼 있는 복제 플러그인 계층이 존재 
    - 계층 내부는 여러 가지 모듈들로 나눠져 있으며, API를 통해 들어온 요청들은 각각 적절한 모듈로 전달
    - 이 계층에서는 로컬 및 그룹 복제의 다른 MySQL 서버에서 실행된 원격 트랜잭션들이 처리되며 트랜잭션들에 대한 충돌 감지 및 그룹 내 전파 등이 수행
    
  - `Group Communication System API & Group Communication Engine (XCom)`
    
    - 마지막 두 계층은 그룹 통신 시스템 API와 그룹 통신 엔진으로 이루어져 있음
    - 상위 플러그인 계층에서는 그룹 통신 시스템 API를 통해 그룹 통신 엔진과 상호작용함
    - 그룹 통신 엔진은 eXtended COMmunication 또는 간단하게 XCom 이라고 함
    - 그룹 복제에 참여중인 다른 MySQL 서버들과 통신 처리를 담당하는 그룹 복제의 핵심 구성 요소

- 그룹 복제에서 또 다른 중요한 부분은 바로 그룹 복제를 구성하는 MySQL 서버의 수임

- 그룹 복제에서는 복제를 처리할 때 그룹 멤버들 간에 합의 절차가 수행되므로 그룹 복제가 정상적으로 동작하려면 그룹의 과반수에 해당하는 서버가 정상적으로 동작하고 있어야 함

- 최소 세 대 이상 필요함

- 그룹 복제를 구성할 때 공식
  ```
  n = 2f + 1 (n: 전체 서버 수, f: 허용하고자 하는 장애 서버 수)
  
  3 -> 5 -> 7 -> 9 ... 홀수
  ```

### 17.2.2 그룹 복제 모드
- 그룹 복제에서는 쓰기를 처리할 수 있는 프라이머리 서버 수에 따라 싱글 프라이머리 모드, 멀티 프라이머리 모드라는 두 가지 동작 모드가 있음

- 사용자는 `group_replication_single_primary_mode` 시스템 변수를 통해 그룹 복제들을 어떤 모드로 동작하게 할 것인지 설정할 수 있음
  
- 값이 ON으로 지정되면 그룹 복제가 싱글 프라이머리 모드로 동작하고 OFF면 멀티 프라이머리 모드로 동작(기본값은 ON)

- MySQL 8.0.13 이상 버전일 경우에만 그룹 복제 모드가 동작중인 상황에서 변경할 수 있고 그 이하 버전은 그룹 복제를 중단한 후 그룹의 모든 멤버들에서 `group_replication_single_primary_mode`를 변경해야 함

- MySQL 8.0.13 이상 에서 아래와 같이 동작중에 변경가능
  - `group_replication_switch_to_single_primary_mode()` : 그룹 복제의 모드를 싱글 프라이머리 모드로 변경
  - `group_replication_switch_to_multi_primary_mode()` : 그룹 복제의 모드를 멀티 프라이머리 모드로 변경

#### 17.2.2.1 싱글 프라이머리 모드
- 싱글 프라이머리 모드는 그룹 내에서 쓰기를 처리할 수 있는 프라이머리 서버가 한 대만 존재하는 형태

- 싱글 프라이머리 모드로 그룹 복제를 처음 구축하는 경우 그룹 복제 구축을 진행한 MySQL 서버가 프라이머리로 지정됨

- 그룹에서 프라이머리 서버가 아닌 다른 서버들은 그룹에 참여하는 시점에 자동으로 `super_read_only` 시스템 변수가 ON으로 설정되어 읽기 전용 모드로 동작하게 됨

- `super_read_only` 가 ON으로 설정되면 SUPER 권한이 있는 사용자도 업데이트가 불가능해짐

  ![CleanShot 2024-02-03 at 15 58 21](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/f46f9ffe-4292-4823-bf41-cfbaef4eecb3)


- 싱글 프라이머리 모드로 동작중인 그룹에서는 다음과 같은 상황에서 그룹 내 프라이머리 서버가 변경될 수 있음
  - 자발적으로 혹은 예기치않게 현재 프라이머리 서버가 그룹을 탈퇴하는 경우
  - `group_replication_set_as_primary()` UDF(User Define Function)를 사용해 그룹의 특정 멤버를 새로운 프라이머리로 지정한 경우 (MySQL 8.0.13 이상의 버전을 사용할 경우에 해당)

- 현재 그룹의 프라이머리가 `group_replication_set_as_primary()`  UDF를 통해 사용자가 지정한 서버로 변경되는 것이 아닌 경우 그룹 복제에서는 정해진 기준들을 바탕으로 새로운 프라이머리를 선출하게 됨
  - 그룹 복제에서 고려하는 기준과 그 우선순위
  
    ![CleanShot 2024-02-03 at 15 58 58](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/862a95a1-8397-4bb1-a951-6681c5ea5e9f)

- 현재 싱글 프라이머리 모드로 동작중인 그룹 복제에서 어떤 서버가 프라이머리인지는 아래와 같이 확인할 수 있다.

```sql
SELECT *
FROM performance_schema.replication_group_members;
```

#### 17.2.2.1 멀티 프라이머리 모드
- 멀티 프라이머리 모드는 그룹 복제에서 그룹 멤버들이 전부 프라이머리로 동작하는 형태로 클라이언트는 그룹의 어떤 MySQL 서버로든 쓰기와 읽기 요청을 보낼 수 있음

![CleanShot 2024-02-03 at 16 00 15](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/32ca875d-0468-4dd2-9716-dffca5a71a33)

- 멀티 프라이머리 모드를 사용하는 구룹에서는 최적의 호환성과 성능을 위해 그룹의 모든 멤버가 동일한 MySQL 버전으로 실행되는 것이 좋음
  - 만약 서로 다른 경우 특정 서버에 기능이 없거나 호환이 되지 않을 가능성이 있음

- 이를 방지하기 위해 그룹 복제에서는 서로 다른 버전을 사용중인 그룹 멤버들 간에 복제가 정상적으로 동작할 수 있도록 그룹복제에 참여할 때 버전호환성을 확인하는 기능이 구현되어 있음

- 그룹복제에서 정의한 호환 가능 기준에 따라 그룹 참여 가능 여부와 읽기 전용 모드 유지 여부를 결정하게 됨

- `그룹 복제에서 버전에 따른 호환 가능 기준`
  
  ![CleanShot 2024-02-03 at 16 01 20](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/96999ea4-c29e-4a9e-b6b5-0df7254c4ea9)

- MySQL 8.0.17 이상의 버전을 사용하는 멤버들은 호환 가능 여부에 따라 그룹 복제에서 읽기 전용 및 읽기-쓰기 모드전환을 자동으로 처리함
  
- 그룹에서 한 멤버가 탈퇴하면 멀티 프라이머리 모드의 그룹 복제에서는 이를 감지해서 현재 그룹 내에서 가장 낮은 MySQL 버전을 사용하는 멤버를 다시 확인한 후 해당 멤버를 자동으로 읽기-쓰기 모드로 전환시킴

- 만약 싱글 프라이머리 모드로 실행중에 `group_replication_switch_to_multi_primary_mode()` UDF를 통해 멀티 프라이머리 모드로 전환되는 경우 그룹 내 멤버들의 MySQL 버전을 바탕으로 각 멤버들을 자동으로 적절한 모드로 설정함

- 그룹 내에서 사용중인 가장 낮은 MySQL 버전보다 높은 MySQL 버전을 사용중인 멤버들은 읽기 전용 모드로 설정하고 가장 낮은 버전을 사용하는 것으로 확인되는 멤버들은 읽기-쓰기 모드로 설정함

### 17.2.3 그룹 멤버 관리 (Group Membership)

- 그룹 복제에서는 현재 어떤 서버들이 그룹에 참여하고 있는지 그룹 멤버들에 대한 목록과 상태 정보를 내부적으로 관리하고 있고 사용자는 `performance_schema.replication_group_members` 테이블을 통해 그룹 멤버 목록을 확인할 수 있음

  ![CleanShot 2024-02-03 at 16 02 23](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/7ff6ce60-2a41-4c38-a95d-77c7441f96b8)

- `MEMBER_STATE 종류`

1. `ONLINE`: 그룹 복제의 한 구성원으로서 정상적으로 있음을 나타낸다.
2. `RECOVERING`: 그룹 복제에 참여하기 위해 그존 그룹 멤버로부터 데이터를 전달받는 복구 작업이 진행되고 있음을 나타낸다.
3. `OFFLINE`: MySQL 서버에 그룹 복제 플러그인이 로딩돼 있으나 아직 그룹 복제에 참여하지 않은 상태를 나타낸다.
4. `ERROR`: 그룹 복제에 속해 있으나 현재 정상적으로 복제가 동작하지 않고 있는 상태를 나타낸다. 복제 동기화에 오류가 발생하는 등의 문제로 이 같은 상태가 표시될 수 있으며, 그 외에도 다양한 문제들로 인해 그룹 멤버의 상태 값이 이 값으로 표시될 수 있다.
5. `UNREACHABLE`: 현재 통신이 불가능하다고 판단되는 멤버에 대해 표시하는 상태 값이다.

<br>

- 그룹 복제가 관리하는 멤버 목록과 상태 정보를 뷰(View) 라고도 하는데 그룹 복제에서 멤버는 새로 가입하거나 탈퇴할 수 있으므로 뷰는 특정 시점의 그룹 멤버 목록이라고 할 수 있음
- 뷰는 뷰 ID라는 고유 식별자를 갖고 있고 그룹 멤버가 변경될 때마다 새로운 뷰 ID 값이 생성됨
- 뷰 ID는 각각의 변경된 뷰를 고유하게 식별하는 것이고 그룹 복제는 이를 통해 뷰의 변경을 추적하고 뷰가 변경된 시점을 구분할 수 있음

```
View ID = [Prefix value]:[Sequence value]

Prefix value = 그 시점의 타임스탬프를 기반
Sequence value = 1부터 증가하는 정수값
```

![CleanShot 2024-02-03 at 16 03 20](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/b2238ab5-2ff7-4297-9cfc-3d0d5e4a708b)

- 그룹에 새로운 멤버가 추가되어 뷰가 변경되는 경우엔 바이너리 로그에도 "View_change" 라는 이벤트로 뷰 변경 내역이 기록됨

```sql
SHOW BINLOG EVENTS IN 'mysql-bin.0000004' FROM 52559 LIMIT 1 \G
```

### 17.2.4 그룹 복제에서의 트랜잭션 처리

- 그룹 복제에서 트랜잭션은 `합의` 또는 `인증` 단계들을 거친 후 최종적으로 그룹의 각 서버들에 적용됨
  
- 합의(Consensus)는 그룹 내 일관된 트랜잭션 적용을 위해 그룹 멤버들에게 트랜잭션 적용을 제안하고 승낙을 받는 과정으로 그룹 멤버 간의 통신 결과를 바탕으로 처리됨
  
- 클라이언트가 한 그룹 멤버에게 트랜잭션을 실행하고 커밋 요청을 보내면 해당 그룹 멤버는 그룹 통신 엔진(XCom)을 통해 트랜잭션에서 변경한 데이터에 대한 WriteSet과 트랜잭션이 커밋될 당시의 트랜잭션의 이벤트 로그 데이터 등이 포함된 트랜잭션 데이터를 그룹의 다른 멤버들로 전파함

- 그룹 복제의 그룹 통신 엔진에서는 트랜잭션 데이터를 전파하면서 Paxos 기반의 프로토콜을 바탕으로 그룹 멤버들 간의 합의를 수행하며 최종적으로 합의가 완려되어 트랜잭션이 실행된 멤버에서 그룹의 과반수 이상에 해당하는 멤버들로부터 응답 메시지를 전달받으면 해당 멤버는 그 다음 프로세스를 진행하게 됨

- 만약 과반수 이상의 멤버들로부터 응답을 받지 못하면 그룹 복제에서 트랜잭션은 적용되지 않으며 클라이언트에는 에러가 반환됨

- 다수의 그룹 멤버들에서 실행된 트랜잭션들은 합의 단계를 거친 후 글로벌하게 정렬되어 각 멤버들에게서 모두 동일한 순서로 `인증(Certification)` 단계를 거치게 됨 

- 인증 단계에서 각 멤버들은 전달받은 트랜잭션 WriteSet 데이터와 로컬에서 내부적으로 관리하고 있는 WriteSet 히스토리 데이터를 바탕으로 해당 트랜잭션이 이미 인증 단계를 거친 선행 트랜잭션과 동시점에 동일한 데이터를 변경한 것인지를 검사해서 트랜잭션 충돌 여부를 확인함

- 이런 트랜잭션 충돌 현상은 멀티 프라이머리모드에서만 발생함

- 인증 단계에서 트랜잭션 충돌이 감지된 트랜잭션은 커밋되지 못하고 롤백됨. 따라서 트랜잭션 충돌이 자주 발생할 수 있는 환경에서는 그룹 복제를 싱글 프라이머리 모드로 사용하는게 더 나은 방법이 될 수 있음

- 각 트랜잭션이 실행된 로컬 멤버에서는 인증 단계를 거친 후 바이너리 로그에 트랜잭션을 기록하고 최종적으로 커밋을 완료하며 클라이언트는 이 시점에 커밋 요청에 대한 응답을 받게 됨

- 원격으로 트랜잭션 데이터를 전달받은 그룹의 다른 멤버들에서는 인증 단계를 수행한 후 함께 전달받은 트랜잭션 로그 데이터를 바탕으로 릴레이 로그 이벤트를 작성함

- 복제 그룹의 어플라이어 스레드에서는 릴레이 로그에 기록된 트랜잭션을 실행하고 바이너리 로그에도 기록해서 최종적으로 서버에 해당 트랜잭션을 적용하게 됨

![CleanShot 2024-02-03 at 16 17 00](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/aaa9339a-eb54-43d3-8ae8-d171b69c8022)


#### 17.2.4.1 트랜잭션 일관성 수준
- 그룹 복제에서 각 멤버들은 모두 동일한 트랜잭션을 적용하지만 실제 적용 시점까지는 완전히 일치하진 않음
  - 한 멤버에서 쓰기를 수행한 후 바로 다른 멤버에서 해당 데이터를 읽었을 때 최신 변경사항이 반영되지 않았을 수 있음

-  프라이머리 장애로 인해 페일오버가 발생하는 경우 새로 선출된 프라이머리가 아직 이전 프라이머리에서 발생했던 트랜잭션을 적용하지 못했다면 오래된 데이터를 읽거나 쓸 수 있음
  
- 일반적으로 그룹 복제가 정상적으로 잘 동작하고 있는 상태에서 멤버 간 데이터 동기화는 빠르게 처리되므로 이 같은 상황은 거의 발생하지 않지만 일시적으로 아주 짧은 순간에 발생할 수 있으며 이런 상황이 매우 민감한 서비스에서는 문제가 될 수 있음

- MySQL 8.0.14버전까지는 위와 같은 상황이 발생하는 것을 방지할 수 있는 방법이 없었지만 8.0.14 버전부터 그룹 복제에서 트랜잭션의 일관성 수준을 설정할 수 있는 기능이 도입되면서 사용자가 필요에 따라 원하는 수준의 일관성을 선택해서 사용할 수 있게 됨

- `group_replication_consisitency` 시스템 변수를 통해 그룹 복제에서의 트랜잭션 일관성 수준을 설정할 수 있으며, 적용 범위는 글로벌 또는 세션 모두 가능

- 설정된 일관성 수준은 읽기 전용 트랜잭션과 읽기-쓰기 트랜잭션에 다른 영향을 미치며 경우에 따라 다른 멤버에서 실행중인 트랜잭션에도 영향을 줄 수 있음

##### 17.2.4.1.1 EVENTUAL 일관성 수준

##### 17.2.4.1.2 BEFORE_ON_PRIMARY_FAILOVER 일관성 수준

##### 17.2.4.1.3 BEFORE 일관성 수준

##### 17.2.4.1.4 AFTER 일관성 수준

##### 17.2.4.1.5 BEFORE_AND_AFTER 일관성 수준

#### 17.2.4.2 흐름 제어(Flow Control)
- 그룹 복제에서 일부 멤버가 다른 멤버들보다 하드웨어 스펙이 낮거나 네트워크 대역폭이 작고 부하가 심하면 특정 멤버에 트랜잭션이 몰려서 지연될 수 있고 트랜잭션 충돌이 일어날 수 있음

- 그룹 복제에서는 이처럼 그룹 멤버 간의 트랜잭션 적용 불균형으로 인해 발생하는 문제를 방지하기 위해 그룹 멤버들의 쓰기 처리량을 조절하는 메커니즘이 구현돼 있으며 이를 `흐름 제어` 라고 함

- 그룹 복제에서는 흐름 제어를 통해 멤버 간 트랜잭션 갭을 적게 유지해서 멤버들의 데이터가 최대한 동기화된 상태로 유지될 수 있게 하며, 그룹에 평소와 다른 워크로드가 유입되는 등의 변화에도 빠르게 적응해서 각 멤버들의 쓰기 처리량이 균등하게 할 수 있게 함
  - 또한 처리량을 줄이지 않음으로써 서버의 자원이 불필요하게 유휴 상태에 놓여 있지 않게 함
    
- 사용자는 `group_replication_flow_control_mode` 시스템 변수를 통해 멤버에서 흐름 제어 기능의 사용 여부를 설정할 수 있음
  - `QUOTA` 모드: 해당 변수의 기본 값, 그룹에서 쓰기를 처리하는 멤버가 정해진 할당량만큼만 쓰기를 처리하도록 제어하는 방식
  - `DISABLE` 모드: 흐름제어 동작 X

- `QUOTA 모드 흐름 제어 동작 방식`

1. 모든 그룹 멤버들의 쓰기 처리량 및 처리 대기 중인 트랜잭션에 대한 통계를 수집해서 멤버의 처리량을 조절할 필요가 있는지 확인한다.
2. 처리량 조절이 필요한 경우 수집된 통계 데이터를 바탕으로 멤버에게 할당할 쓰기 처리량을 계산한 후 멤버가 계산된 최대 쓰기 처리량을 넘어 쓰기를 처리하지 않도록 멤버의 쓰기 처리를 제한한다.

- `흐름 제어에서 수집하는 데이터`

1. 인증(Certification) 큐 크기
2. 적용(Application) 큐 크기
3. 인증된 총 트랜잭션 수
4. 적용된 원격 트랜잭션 수
5. 로컬 트랜잭션 수

<br>

- 통계 정보는 `group_replication_flow_control_period` 시스템 변수에 지정된 시간 마다 수집 및 공유됨
  - 이 변수는 흐름 제어가 동작하는 주기를 의미

- `group_replication_flow_control_period` 의 기본값은 매초마다 동작하고 모든 멤버에서 같은 값을 갖는게 좋다.

- 흐름제어에서 수집된 통계 정보 중 인증 큐 크기와 적용 큐 크기를 바탕으로 멤버의 처리량을 조절할 것인지를 판단

- 로컬 멤버를 포함해서 그룹의 모든 멤버들에서 트랜잭션 처리 과정 중 트랜잭션의 충돌을 감지하는 인증 단계와 실제로 트랜잭션을 반영하는 적용 단계에서 얼마나 많은 트랜잭션이 대기하고 있는지를 확인

- `흐름제어 임계값 설정`

  ![CleanShot 2024-02-03 at 16 21 56](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/df51746d-c465-4c8e-bfc2-7e2505a3a83f)

- 흐름제어에서는 멤버의 쓰기 처리량을 조절할 필요가 있다고 판단되면 통계 정보를 바탕으로 그룹에서 트랜잭션 적용이 가장 뒤처진 멤버가 처리할 수 있는 수준으로 멤버의 쓰기 처리량을 계산함

- 위에서 처리한 값이 멤버에 바로 적용되는 것은 아니고 흐름 제어에서 멤버에게 할당하는 쓰기 처리량과 관련된 시스템 변수들에 사용자가 설정한 값을 참조해서 최종적으로 할당할 쓰기 처리량을 결정하게 됨

- `흐름제어 쓰기 처리량 관련 시스템 변수`
  
  ![CleanShot 2024-02-03 at 16 22 21](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/3c81e79c-6c5b-44b8-9d5d-22e8f80cba4f)
![CleanShot 2024-02-03 at 16 22 40](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/95c1b0d0-2ccb-4572-a04d-cdcbcdc5aba6)

<br>

- `흐름 제어에서 멤버에게 할당할 쓰기 처리량을 계산하는 로직`

  ![CleanShot 2024-02-03 at 16 22 56](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/874de38c-43d6-4cca-a4a9-6a13f7e81d44)

  ![CleanShot 2024-02-03 at 16 23 14](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/5765c5f4-fe3e-4816-afd3-a11fb0db7098)

<br>

- 흐름 제어와 관련된 시스템 변수들은 동적으로 변경 가능하며, 그룹 복제를 중단하지 않더라도 변경된 값으로 즉시 반영됨

### 17.2.5 그룹 복제의 자동 장애 감지 및 대응
- 추가 예정

### 17.2.7 그룹 복제 요구사항
- 그룹 복제를 사용하려는  MySQL 서버에서는 다음 요구사항들을 충족해야 함

- `InnoDB 스토리지 엔진 사용`
  
  - 데이터가 저장되는 테이블은 방드시 InnoDB 스토리지 엔진을 사용해야 함 (트랜잭션을 지원하는 엔진이 필요하기 때문에)
  - 다른 스토리지 엔진을 사용할 경우 그룹 복제에서 에러가 발생할 수 있음
    - 따라서 MySQL 설정 파일에 `disabled_storage_engines` 시스템 변수를 설정해서 다른 스토리지 엔진의 사용을 방지할 수 있음
  

  ```
  [mysqld]
  disabled_storage_engines="MyISAM,BALCKHOLE,FEDERATED,ARCHIVE,MEMORY"
  ```
  
- `프라이머리 키 사용`
  
  - 그룹에서 복제될 모든 테이블들은 프라이머리 키를 갖고 있어야하고 명시적인 프라이머리 키가 없다면 NULL값을 허용하지 않는 유니크 키가 테이블에 반드시 존재해야 함
  - 이러한 키들은 모든 데이터에 대해 고유한 식별자 역할을 하고 그룹 복제에서는 이를 바탕으로 트랜잭션 간 충돌을 방지함
  
- `원활한 네트워크 통신 환경`
  
  - 그룹 복제는 그룹 멤버들 간의 양방향 통신을 통해 이뤄지므로 그룹 복제의 성능과 안전성은 서버가 속한 네트워크 환경에 영향을 받음
  
- `바이너리 로그 활성화`
  
  - 그룹 복제는 기본 MySQL 복제와 마찬가지로 복제에서 바이너리 로그를 사용하므로 서버에서 바아니러 로그가 활성화되어 있어야 함
  - MySQL 8.0부터 바이너리 로그는 기본적으로 활성화 됨
  
- `ROW 형태의 바이너리 로그 포맷 사용`
  
  - 그룹 복제는 ROW 포맷 기반의 복제를 사용해 트랜잭션으로 인해 변경된 데이터가 그룹 멤버들에서 일관되게 적용될 수 있게 함
  
- `바이너리 로그 체크섬 설정`
  
  - MySQL 8.0.20 버전까지는 그룹 복제에서 바이너리 로그 체크섬 기능을 지원하지 않으므로 `binlog_checksum` 시스템 변수의 값을 `NONE` 으로 설정해야 함
  - MySQL 8.0.21 버전부터는 체크섬 기능을 지원하므로 해당 변수에 사용자가 원하는 값을 설정할 수 있음
  
- `logslave_updates 활성화`
  
  - 새로운 멤버가 그룹에 참여하면 해당 멤버는 기존 그룹 멤버들과 동일하게 그룹의 최신 데이터를 가질 수 있도록 그룹 복제의 분산 복구 작업을 수행하는데, 이때 기존 그룹 멤버의 바이너리 로그를 복제해서 자신에게 적용하므로 그룹 멤버들은 그룹에서 발생한 트랜잭션들을 모두 각자의 바이너리 로그에 기록해야 함
  - 또한 그룹 복제에서 그룹의 모든 멤버들이 쓰기를 수행하는 프라이머리 서버가 될 수 있으므로 그룹 복제를 설정할 MySQL 서버에서는 `log_slave_updates` 시스템 변수가 반드시 활성화돼 있어야 함
  
- `GTID 사용`
  
  - 그룹 복제는 기본적으로 GTID를 사용하므로 그룹 복제에 설정할 MySQL 서버는 GTID가 활성화 될 수 있또록 설정 파일에 다음과 같이 옵션을 설정해야 함
  

  ```
  [mysqld]
  dtid_mode=ON
  enforce_gtid_consistency=ON
  ```
  
- `고유한 server_id 값 사용`
  
  - 그룹 복제에 참여하는 MySQL 서버들은 모두 각기 다른 고유한 `server_id` 값을 가져야 함
  
- `복제 메타데이터 저장소 설정`
  
  - 그룹 복제에서 복제 관련 메타디에터는 데이터는 일관성을 위해 파일이 아닌 테이블에 저장돼야 함
  - 따라서 MySQL 서버에서 `master_info_repository` 및 `replay_log_info_repository` 시스템 변수의 값이 `TABLE`로 설정돼 있어야 함
  
- `트랜잭션 WriteSet 설정`
  
  - 트랜잭션에서 변경한 데이터에 대한 정보, 즉 트랜잭션이 WriteSet이 수집될 수 있또록 `transaction_write_set_extraction` 시스템 변수가 `XXHASH64`로 설정돼야 함
    - 트랜잭션의 WriteSet은 그룹 복제에서 트랜잭션 간 충돌을 탐지하는 트랜잭션 인증 단계에서 사용됨
  
- `테이블 스페이스 암호화 설정`
  
  - `default_talbe_encryption` 시스템 변수는 모든 그룹 멤버에 동일한 값으로 설정돼야 함
  
- `lower_case_table_names 설정`
  
  - `lower_case_table_names` 시스템 변수는 모든 그룹 멤버에서 동일한 값으로 설정돼야 함
  
- `멀티 스레드 복제 설정`
  
  - 그룹 복제에서도 멀티 스레드 복제 기능을 사용해 트랜잭션을 병렬로 적용할 수 있음
  
  ```
  [mysqld]
  salve_parallel_workers=N
  slave_parallel_tpye=LOGICAL_CLOCK
  slave_preserve_commit_order=1
  ```

### 17.2. 그룹 복제 제약 사항
- `그룹 복제 제약 사항`
  - 갭 락은 갭 락을 발생시킨 트랜잭션이 실행된 멤버에서만 유효하며, 그룹 복제의 트랜잭션 인증 단계에서 해당 락 정보는 공유되지 않음
    - 따라서 갭락이 사용되지 않는 `READ-COMMITED` 트랜잭션 격리수준을 사용하는 것이 좋음
  
  - 테이블락 및 네임드락도 그룹단위로 락 정보가 공유되지 않음
    - 그룹 복제의 인증 단계에서는 이 두 락을 고려하지 않음
  
  - 그룹 복제에서 바이너리 로그 체크섬 기능은 MySQL 8.0.21 버전부터 사용 가능하며 그 이전 버전에서는 지원하지 않음
  
  - 멀티 프라이머리 모드로 동작중인 그룹에서는 `SERIALIZABLE` 트랜잭션 격리수준을 사용할 수 없음
  
  - 멀티 프라이머리 모드로 동작중인 그룹에서 동일한 테이블에 대해 서로 다른 멤버에서 동시에 실행되는 DDL 및 DML 문은 지원하지 않음
  
  - 멀티 프라이머리로 동작 중인 그룹에서 외래키가 존재하는 테이블, 특히 `CASCADE` 제약 조건이 사용된 테이블은 지원하지 않음
    - `CASCADE` 제약 조건으로 그룹 멤버 간에 데이터가 일치하지 않을 수 있음. 이를 위해 `group_replication_enforce_update_everywhare_checks` 시스템 변수가 활성화되면 그룹 복제에서는 실행된 쿼리에 대해 멀티 프라이머리 모드와 호환 가능하능한지를 검사하게 할 수 있음
    - 싱글 프라이머리 모드에서는 데이터 일관성을 해칠 수 있는 문제는 발생하지 않으므로 해당 시스템변수는 비활성화해서 사용해야 함
  
  - 멀티 프라이머리 모드에서 `SELECT ... FOR UPDATE` 구문을 사용할 때 데드락이 발생할 수 있음
  
  - 그룹 복제에서 복제 필터 기능은 사용할 수 없음
    - 그룹 멤버가 그룹 복제와 더불어 그룹 외부의 다른 소스 서버에 대한 일반 복제도 함께 진행하는 경우 일반 복제에 대한 필터링은 설정할 수 있음
  
  - 그룹 복제는 최대 9대의 서버까지 구성 가능
    - 이미 9대로 구성된 그룹 복제에서 새로 멤버가 추가되는 경우에는 에러가 발생

## 17.3 MySQL 셸
- MySQL 셸은 MySQL을 위한 고급 클라이언트 툴로, 단순히 SQL문 실행만 가능했던 기존 클라이언트 툴인 mysql 보다 좀 더 확장된 기능들을 사용자에게 제공함
  - 단순 SQL뿐만 아니라 자바스크립트와 파이썬 모드도 제공

  ![CleanShot 2024-02-03 at 15 41 40](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/73fa0593-8f1a-4aca-a1fe-846892bcdc46)

- MySQL 셸은 아래와 같은 API도 제공함
  - X 프로토콜을 사용해 MySQL 서버에서 관계형 데이터와 문서 기반 데이터를 모두 처리할 수 있게 하는 X DevAPI
  - MySQL 서버의 설정을 변경하고 InnoDB 클러스터 및 InnoDB 레플리카셋을 구축할 수 있게 하는 Admin API

- MySQL 셸에 내장돼 있는 글로벌 객체들과 각 객체에 구현돼 있는 메서드를 통해 API를 사용할 수 있음

- MySQL 셸의 글로벌 객체는 자바스크립트모드, 파이썬 모드에서만 사용할 수 있음

- `MySQL 셸의 글로벌 객체`

  ![CleanShot 2024-02-03 at 15 40 46](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/72d7fcf3-6727-4684-8716-52eaff395293)

  ![CleanShot 2024-02-03 at 15 41 20](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/d881c288-a113-4bda-ba4c-19e24d6681a2)

## 17.4 MySQL 라우터
- MySQL 라우터는 InnoDB 클러스터에서 애플리케이션 서버로 유입된 쿼리 요청을 클러스터 내 적절한 MySQL 서버로 전달하고 MySQL 서버에서 반환된 쿼리 결과를 다시 애플리케이션 서버로 전달하는 proxy 역할을 수행함

- MySQL 라우터의 중요 기능
  - InnoDB 클러스터의 MySQL 구성 변경 자동 감지
  - 쿼리 부하 분산
  - 자동 페일 오버

  ![CleanShot 2024-02-03 at 15 39 26](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/afda17a4-5a73-476a-aa2b-ece8ea9a9d02)

- MySQL 라우터는 클러스터 내 MySQL 서버들에 대한 정보를 메모리에 캐시하고 있고 주기적으로 이 정보를 갱신함
  - 따라서 MySQL 라우터를 사용하는 애플리케이션은 MySQL 서버의 커넥션 설정 정보를 직접 변경할 일이 없음
  
- MySQL 라우터는 부하 분산도 지원하는데 사용자는 MySQL 라우터의 부하 분산 방식을 지정할 수 있음

- MySQL 라우터는 MySQL 서버에 장애가 발생한 경우 자동으로 다른 MySQL 서버로 쿼리를 재시도하는데 이때 지정된 부하 분산 방식에 따라 재시도할 MySQL 서버를 결정하게 할 수 있음

## 17.5 InnoDB 클러스터 구축

### 17.5.1 InnoDB 클러스터 요구사항
- InnoDB 클러스터는 기본적으로 그룹 복제 기반으로 동작하기 때문에 그룹 복제의 요구 사항을 충족해야함

- InnoDB 클러스터를 구헝하는 각 구성 요소들은 최소한 다음과 같은 버전으로 설치 되어야함
  - MySQL 서버 5.7.17 이상
  - MySQL 셸 1.0.8 이상
  - MySQL 라우터 2.1.2 이상

- InnoDB 클러스터의 MySQL 서버들은 모두 Performance 스키마가 활성화 돼있어야 함

- MySQL 셸을 사용해 InnoDB 클러스터를 구성하기 위해 MySQL 셸이 설치될 서버에 파이썬 2.7이상의 버전으로 설치돼 있어야 함

### 17.5.2 InnoDB 클러스터 생성                                                                                                                                                                                                                                                                                                                                   

#### 17.5.2.1 사전 준비
- InnoDB 클러스터에 사용될 MySQL 서버들은 InnoDB 클러스터 요구사항을 충족하도록 서버 옵션들이 적절하게 설정되어 있어야함
  - MySQL 셸을 이용해서 간단하고 편리하게 설정할 수 있음
  
  ![CleanShot 2024-02-03 at 15 19 22](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/2b3a893f-8e5f-42b7-a0cd-60f0323b3a18)

  ![CleanShot 2024-02-03 at 15 19 39](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/1a31890d-9f76-408e-be53-04ee63abf5c7)

  ![CleanShot 2024-02-03 at 15 19 52](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/1e23953a-dd45-481e-b45a-de7ba093af95)

- 앞서 설정한 내용을 나머지 MySQL 서버에서도 동일하기 수행 

#### 17.5.2.2 InnoDB 클러스터 생성
- 모든 MySQL 서버들이 준비가 완료되면 클러스터 생성을 위해 MySQL 서버 중 한 곳에 접속
  
  ![CleanShot 2024-02-03 at 15 22 26](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/823b2313-d7a8-4bcb-b87e-ca6f5927cd99)

- 복잡한 그룹 복제 설정없이 클러스터 생성을 `dba.createCluster()` 를 통해 할 수 있음

  ![CleanShot 2024-02-03 at 15 24 30](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/e23b8f7d-0ee8-4ad5-8faf-76807176236c)

- InnoDB 클러스터는 기본적으로 싱글 프라이머리 모드로 생성되며 처음 클러스터 생성을 진행한 MySQL 서버가 프라이머리로 지정됨

- 만약 멀티 프라이머리로 클러스터를 생성하고 싶다면 아래와 같은 옵션을 지정해야 함

  ![CleanShot 2024-02-03 at 15 25 29](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/6987b8de-4c64-4ce1-8b73-02c3c2f74e0d)

- 클러스터 상태 조회와 같은 클러스터 관련 명령들은 클러스터 객체를 통해 실행할 수 있음

```javascript
var cluster = dba.getCluster()
cluster.status()
```

![CleanShot 2024-02-03 at 15 26 36](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/3b84a7af-e5c2-4c5a-bdab-55ac163bf900)

#### 17.5.2.3 InnoDB 클러스터 인스턴스 추가
- 클러스터에 서버를 추가하려면 `<Cluster>.addInstance()` 메서드를 사용
  - 클러스터의 추가는 프라이머리가 아니여도 가능함
  - 현재 클러스터에 존재하는 서버와 추가될 서버의 상태를 비교해서 바로 추가되는지 혹은 기존 서버와 동기화가 필요한지 판단
    - 데이터 동기화가 필요하면 그룹 복제의 분산 복구를 수행
      - 분산 복구 방식에 대해 선택할 수 있음

#### 17.5.2.4 MySQL 라우터 설정
- 별도의 라우터용 서버가 있고, 라우터가 설치되어 있다고 가정

- MySQL 라우터 부트스트랩 명령

```
mysqlrouter --bootstrap icadmin@localhost:3306 --name icroute1 \
--directory /tmp/myrouter --acount icrouter --user root
```

- `사용된 옵션의 역할`

  ![CleanShot 2024-02-03 at 15 30 54](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/2444c76b-cd03-4649-96c4-ea6746f73f7c)

- InnoDB 클러스터에서 부트스트랩 시 자동으로 생성된 라우터용 DB 계정과 라우터 서버 등록 내역을 확인할 수 있음

  ![CleanShot 2024-02-03 at 15 32 43](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/f2cf78ab-117c-4d3d-a66c-9ee1bb1ecdc9)

- 부트스트랩 명령이 완료되면 아래 네개의 포트를 사용하도록 설정된 것을 확인할 수 있음
  - MySQL 기본 프로토콜로 연결되는 읽기 전용 포트 
  - MySQL 기본 프로토콜로 연결되는 읽기-쓰기용 포트
  - X 프로토콜로 연결되는 읽기 전용 포트
  - X 프로토콜로 연결되는 읽기-쓰기용 포트
  
    ![CleanShot 2024-02-03 at 15 34 13](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/6d8cb226-5cf6-4501-91fa-c00e89af0c0e)
  
    ![CleanShot 2024-02-03 at 15 34 28](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/a1ddb80e-ea49-4aa6-8206-bb36cb2fdd7b)

- 설정 파일에서 `metadata_cahce` 섹션과 `routing` 섹션은 MySQL 라우터 동작에서 가장 중요한 부분
  - MySQL 라우터는 내부적으로 플러그인 형태의 아키텍처로 구성되어 있는데 하나는 메타데이터 캐시 플러그인, 커넥션 라우팅 플러그인인에 대한 설정

- 메타데이터 캐시 플러그인은 라우터에서 접속할 InnoDB 클러스터의 정보를 구성하고 관리하는 부분을 담당

- 커넥션 라우팅 플러그인은 애플리케이션 서버로 부터 유입된 쿼리 요청을 InnoDB 클러스터로 전달하는 부분을 담당

- 두 섹션에 설정돼 있는 하위 옵션 중 다음 옵션들은 필요에 따라 적절한 값으로 재설정해서 사용하는 것이 좋음
  - 설정 값

  ![CleanShot 2024-02-03 at 15 35 52](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/294ae5cf-693d-42c3-9b99-ca41a255e481)

  ![CleanShot 2024-02-03 at 15 36 08](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/1730ed26-8e59-4b5e-8d08-dc481f49ed9a)

  ![CleanShot 2024-02-03 at 15 36 23](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/1e294add-b3a5-4ffc-9554-e0a7dd7b8714)

- MySQL 라우터에 대한 부트스트랩이 완료되면 라우터는 자동으로 실행되지 않으므로 다음과 같이 수동으로 실행

```
/tmp/myrouter/start.sh

# netstat으로 4개의 TCP 포트 확인
netstat -lntp | grep mysqlrouter
```

- 클라이언트는 더이상 InnoDB 클러스터에 연결하지 않고 MySQL 라우터로 연결한다는 점

- 라우터를 통해 실제 쿼리가 어디 서버에 전달되었는지 확인하려면 간단하게 `hostname`과 `port` 시스템 변수를 조회하면 됨

  ![CleanShot 2024-02-03 at 15 37 48](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/1434161e-0a86-460b-8914-b55b844b5024)

- 쓰기 포트로 연결한 경우 실행 쿼리는 프라이머리 서버로 전달되며 읽기 포트로 연결해서 실행한 쿼리는 세컨더리 서버들 중 한 서버로 전달됨

## 17.6 InnoDB 클러스터 모니터링
- MySQL 셸을 통해 InnoDB 클러스터 구성의 전반적인 상태를 확인할 수 있음
- 클러스터의 복제 토폴로지 구성을 간략하게 확인하고 싶은 경우 `<Cluster>.describe()` 메서드를 사용하면 됨

  ![CleanShot 2024-02-03 at 15 08 33](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/3b1ed16a-000d-483c-af29-44aa987721bd)

- 클러스터의 전반적인 상태를 좀 더 자세하게 사용하고 싶다면 아래와 같이 사용할 수 있음
  - `<Cluster>.status()` 메서드에 extended 옵션 추가
  
  ![CleanShot 2024-02-03 at 15 08 59](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/dbcf7a6c-f013-43c7-9201-b80a59a7325b)

  - `일반적인 status()에서 추가된 부분`

    ![CleanShot 2024-02-03 at 15 11 03](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/24c6b42d-b3d0-4a81-98d9-d23df6a1626c)

- extended 옵션의 의미(MySQL 셸 8.0.17미만에서는 0 or 1만 가능)
  - `<Cluster>.status()` 메서드는 어떠한 옵션도 지정하지 않고 실행하면 기본적으로 `extended` 옵션이 0

    ![CleanShot 2024-02-03 at 15 11 38](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/07283473-fdcb-48d3-a40c-0a172a6048bd)

## 17.7 InnoDB 클러스터 작업

### 17.7.1 클러스터 모드 변경
- InnoDB 클러스터는 기본적으로 싱글 프라이머리 모드로 생성됨
- 상황에 따라 멀티 프라이머리 모드로 전환하고 싶을때 InnoDB 클러스터의 구성 요소들의 버전이 모두 8.0.14 이상인 경우 이러한 클러스터 모드 변경을 클러스터를 중단하지 않고 온라인으로 수행할 수 있고 MySQL 셸에서 손쉽게 사용 가능함
- 8.0.14 버전 미만인 경우 클러스터를 해체 후 다시 원하는 모드로 설정해서 재생성 해야만 변경 가능함

- `클러스터 변경 메서드`

  ![CleanShot 2024-02-03 at 15 00 15](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/2cb3c3a0-ef29-459c-ad9c-a79000c52b2c)

### 17.7.2 프라이머리 변경
- InnoDB 클러스터 구성원들의 버전이 모두 8.0.14이상인 경우 사용자는 현재 싱글 프라이머리 모드로 동작중인 클러스터의 프라이머리 서버를 강제로 특정 서버로 변경할 수 있음

  ![CleanShot 2024-02-03 at 15 01 05](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/2afded82-3416-4c29-aeb7-a5e8e92c9b88)
  
### 17.7.3 인스턴스 제거
- 서버 교체나 장애 등의 문제로 클러스터의 특정 인스턴스를 제거해야하는 경우 다음 메서드를 사용할 수 있음

  ![CleanShot 2024-02-03 at 15 01 33](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/986be612-2f5e-4c6c-a9cf-e19e1c5a02d3)

  - 서버를 제거하는 시점에 제거 대상 서버에 아직 적용되지 못한 클러스터의 트랜잭션이 존재할 수 있는데 이 경우 제거 명령은 `dba.gtidWaitTimeout` 옵션에 설정된 시간만큼 기다림 (기본값 60초)

    ![CleanShot 2024-02-03 at 15 02 06](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/ea36e736-57c9-4a18-8416-6832fc4a84fe)
    
    - `dba.gtidWaitTimeout` 에 설정된 시간이 초과하면 제거 실행이 중단됨
    - `dba.gtidWaitTimeout` 옵션에 설정된 시간이 초과하더라도 서버를 클러스터에서 강제로 제거하려면 제거 명령에 "{force:true}" 옵션을 지정하면 됨
    - 위 방법은 제거 대상 서버에 적용이 누락된 클러스터의 트랜잭션이 존재할 수 있고 이로 인해 나중에 클러스터에 다시 참여하지 못할 수 있기 때문에 제거 대상 서버를 더이상 클러스터에서 사용하지 않을 예정인 경우에만 해당 옵션을 사용하는 것이 좋음

### 17.7.4 클러스터 해체
- 클러스터의 사용 종료 혹은 클러스터 단위의 설정 변경 등으로 클러스터를 해체 후 재생성하고자 할 때 MySQL 셸에서 클러스터를 해체할 수 있음

  ![CleanShot 2024-02-03 at 15 03 12](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/538b38ee-9098-4e2d-8c3b-75b65d926257)

  - 마찬가지로 `dba.gtidWaitTimeout` 만큼 대기하고 이 시간을 초과하면 해체 명령이 중지됨
  - "{force:true}" 옵션 설정이 가능함
  - 해체 작업 과정에서 누락된 서버가 존재하면 경우에 따라 스플릿 브레인 상황이 발생할 수 있기 때문에 이러한 부분이 전혀 문제가 되지 않을 것으로 예상되는 경우에만 해체 작업을 진행하는 것이 좋음

### 17.7.5 클러스터 및 인스턴스 설정 변경
- 클러스터의 현재 설정을 확인하려면 `<Cluster>.options()` 메서드를 사용해서 클러스터의 이름, 클러스터의 전역 설정, 태그 정보, 클러스터의 각 서버의 설정 정보를 JSON 포맷으로 확인할 수 있음

  ![CleanShot 2024-02-03 at 15 03 56](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/bb742848-1e3b-4281-a013-2e624c3de656)

- `<Cluster>.options()` 를 통해 보여지는 모든 설정을 다 변경할 수 있는 것은 아님
  - MySQL 셸 버전에 따라 변경 가능한 설정이 다름 
  
  ![CleanShot 2024-02-03 at 15 05 13](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/2c2a2729-0fbb-4bda-be9b-3e409282a418)
  
  ![CleanShot 2024-02-03 at 15 05 31](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/0c70d705-f892-477c-8ec0-1e2d3703e54f)

#### 17.7.4.2 빌트인 태그
- 사용자는 클러스터 및 인스턴스에 태그를 설정할 수 있고 이런 태그 기능은 MySQL 셸 8.0.21 이상의 버전부터 사용 가능
- 사용자는 태그를 설정할때 태그의 Key-Value 값을 자유롭게 지정할 수 있지만 예외적으로 태그의 키값은 언더스코어(`_`) 로 시작할 수 없음
  - MySQL에서 언더스코어로 시작하는 태그는 내부적으로 미리 정의된 빌트인 태그로 인식하기 때문에

- `빌트인 태그`

  ![CleanShot 2024-02-03 at 14 56 29](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/be417cdb-ad95-45f8-8f9c-4d69d7cf98ed)

  - 빌트인 태그를 사용하면 유인되는 클라이언트 쿼리 요청으로부터 특정 인스턴스를 숨길 수 있음
    - 다음과 같은 상황에 유용함
      - 클러스터 인스턴스들을 순차적으로 버전 업그레이드하는 것과 같이 MySQL 서버 운영 작업을 진행하는 경우
      - 복제 지연이 발생한 인스턴스를 일시적으로 클라이언트 쿼리 요청에서 제외시키는 경우
      - 클라이언트에서 실행한 쿼리에 영향을 줄 수 있는 백업이 수행되거나 혹은 분석 전용으로 사용되는 인스턴스 클라이언트 쿼리 요청에서 제외시키는 경우

## 17.8 InnoDB 클러스터 트러블 슈팅

### 17.8.1 클러스터 인스턴스 장애
- 클러스터의 인스턴스들은 기본적으로 5초동안 인스턴스가 응답이 없으면 클러스터의 다른 인스턴스들이 해당 인스턴스에 문제가 있는 것으로 간주
  - `expelTimeout` 옵션에 설정된 시간만큼 추가적으로 대기 후 최종적으로 응답이 없는 인스턴스를 클러스터의 그룹 복제에서 내보냄
- 인스턴스가 네트워크 문제로 통신이 단절되고 통신이 회복되면 클러스터는 자동으로 `autoRejoinTries` 옵션에 설정된 횟수만큼 재연결 시도를 함
- 만약 `autoRejoinTries` 옵션에 설정된 횟수만큼 시도해도 클러스터에 연결하지 못하면 `exitStateAction` 옵션에 설정된 조치를 수행함
  - 이 경우 인스턴스가 클러스터에 다시 연결되려면 사용자의 개입이 필요
- 사용자는 MySQL 셸에서 `<Cluster>.rejoinInstance(instance)` 메서드를 실행해 인스턴스를 클러스터에 다시 참여시킬 수 있음

### 17.8.2 클러스터의 정족수 손실
- 클러스터에서 과반수 이상의 인스턴스에 장애가 발생한 경우 클러스터는 쓰기 요청과 토폴로지 변경을 처리할 수 없음
  - 과반수의 인스턴스에 대한 동의가 필요하기 때문
- 정족수가 손실된다면 반드시 사용자의 개입이 필요함
- 사용자는 MySQL 셸에서 `<Cluster>.forceQuorumUsingPartitionOf(instance)` 메서드를 사용해 클러스터를 강제로 재구성할 수 있음
  - 해당 명령은 인자로 지정한 인스턴스에 접속해 해당 인스턴스에 정상적인 상태로 인식되는 클러스터 내 다른 인스턴스를 확인한 후 그 인스턴스들로 클러스터를 재구성

## 17.9 InnoDB 클러스터 버전 업그레이드
- 클러스터는 여러 요소로 구성되므로 아래와 같이 안전하게 업그레이드를 진행하는것을 권장함
  1. MySQL 라우터 업그레이드
  2. MySQL 셸 및 InnoDB 클러스터 메타데이터 스키마 업그레이드
  3. MySQL 인스턴스 업그레이드 (세컨더리부터 프라이머리까지)
- 클러스터 버전 업그레이드에는 `_hidden` 옵션을 활용하는 것이 좋음

- 싱글 프라이머리 모드 클러스터의 인스턴스 롤링 업그레이드

  ![CleanShot 2024-02-03 at 14 50 31](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/758c0643-727c-4357-9304-ccaa8507ce67)

## 17.10 InnoDB 클러스터 제약 사항
- InnoDB 클러스터는 그룹 복제를 기반으로 구성되므로 클러스터의 제약 사항은 기본적으로 그룹 복제의 제약사항들을 포함

- 이 외 제약사항

  ![CleanShot 2024-02-03 at 14 50 11](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/2c532b7a-c526-4fdd-9334-f9981ddfbec6)
