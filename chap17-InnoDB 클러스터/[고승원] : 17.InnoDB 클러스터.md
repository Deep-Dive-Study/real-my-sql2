# 17장 InnoDB 클러스터

레플리카는 Failover를 지원하지 않으므로 소스 서버가 죽었을 때 소스 서버로 승격 시키기 위한 일련의 작업을 해야한다. (기존 소스 서버 닫고, 레플리카 서버 승격하고, 애플리케이션이 바라보는 DB 변경)

Failover를 자동화 하기 위한 방법은 수동, 자동(서드파티) 등이 있는데 MySQL은 InnoDB 클러스터가 이런 역할을 한다. (5.7 부터 지원)

# 1. InnoDB 클러스터 아키텍처

InnoDB 클러스터는 하나의 기능이 아닌 여러 요소의 집합체다.

- 그룹 복제 : 소스 서버를 레플리카 서버로 동기화, 복제화에 참여하는 MySQL 서버 멤버쉽 관리
- MySQL 라우터 : 애플리케이션 서버와 MySQL 서버의 중간에서 쿼리를 적절히 전달하는 프록시
- MySQL 셸 : 기본적인 SQL, js, python 스크립트 작성 및 admin API 제공

![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/85796588/17679033-753b-4e2e-9368-d4c70fa015cb)

위 세가지 요소가 사진과 같이 배치되어 구성된다.

**그룹 구성 조건**

- 스토리지 엔진은 InnoDB만 사용 가능하다.
- 프라이머리는 한대 이상이어야 한다.
- 그룹 복제를 구성할 때 MySQL 서버는 3대 이상이어야 한다.

**라우터**

- 클라이언트는 MySQL에 쿼리를 보내지 않고, MySQL 라우터에 연결해 쿼리를 실행한다.
이때 라우터는 MySQL 서버에 대한 메타데이터를 바탕으로 적절한 MySQL 서버에 전달한다.

**셸**

- 사용자가 손쉽게 InnoDB 클러스터를 생성하고 관리하도록 API를 제공한다.
- InnoDB 클러스터 상태 확인, 설정 변경 등 기능을 한다.
- MySQL 설정 작업을 할 때는 직접 MySQL 서버에 연결해서 작업해야 하고, 쿼리의 경우는 라우터를 사용한다.

**장애 발생시**

- MySQL 서버에 장애가 발생하면 **그룹 복제**가 먼저 이를 감지해서 자동으로 복제 그룹에서 제외시킨다.
- **MySQL 라우터**는 복제 토폴로지 변경을 인식하고 메타데이터를 갱신해서 실행된 쿼리가 정상적인 MySQL 서버로만 전달되도록 한다.

# 2. 그룹 복제

### 특징

- MySQL replication 프레임워크를 기반으로 한다.
- 내부적으로 Row포맷의 바이너리 로그와 릴레이 로그, GTID를 사용한다.
- 기존 replication과 유사하지만, 트랜잭션 처리는다르다.
    - 그룹 내 서버끼리 통신하며, 양방향으로 이루어진다.
    
  ![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/85796588/bb043f05-d51b-4217-8b2b-39d7fae6116c)
    

**복제 방법**

![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/85796588/6e4e1f50-5a70-4433-9269-96967a5cbfe8)

- 비동기, 반동기도 아닌 그룹 복제 방법이 있다. 이는 반동기와 유사하지만 다른 부분이 있다.
- 트랜잭션을 처리할 때 소스 서버와 레플리카 서버 사이에 certify 단계가 추가되었다.
    - 한 서버에서 커밋될 준비가 되면, 다른 서버로 전송하고, 과반수 이상의 멤버로부터 응답을 받으면 그때 커밋처리를 한다.
    - 과반수 이상의 응답을 받지 못하면 트랜잭션은 적용되지 않는다. (소스 서버 포함)
- 그룹 복제 기능
    - 그룹 멤버 관리
    - 그룹 단위의 트랜잭션 적용 (충돌 감지)
    - 자동 페일오버
    - 자동 분산 복구

## 2.1 그룹 복제 아키텍처

그룹 복제를 하려면 그룹 복제 플러그인을 설치해야 한다.

![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/85796588/df4bce31-6f41-469f-8377-c9ac2daaff8c)

다음과 같이 그룹에 속한 MySQL 서버들은 그룹 복제 플러그인을 통해서 복제 및 동기화 한다.

**플러그인 구성 요소**

- Plugin API : MySQL 서버와 상호작용을 하기 위한 API
- Replication Plugin : 그룹 복제 기능의 실질적인 구현이 되어있다. (요청, 트랜잭션처리, 전파, 분산 복구 등)
- Group Communication System API : 상위 플러그인 계층과 Group Communication Engine이 상호작용 하도록 한다.
- Group Communication Engine : 다른 MySQL 서버와의 통신 처리를 담당하는 핵심 구성요소이다.
    - 그룹 복제와 분산 시스템 등에서 구성원들 간의 합의 처리를 위해 알고리즘을 사용한다. (**Paxos**, Raft)
    - 데이터변경이 한 대에서만 일어나는 경우 Raft, 아니면 Paxos를 사용

## 2.2 그룹 복제 모드

그룹 복제는 크게 두가지로 나뉜다. 싱글 프라이머리, 멀티 프라이머리 (group_replication_primary_mode)

### 2.2.1 **싱글 프라이머리 모드**

프라이머리 서버 지정 루트

- 처음 그룹 복제를 구축한 서버
- 프라이머리 서버가 그룹을 탈퇴하는 경우
- group_replication_set_as_primary 를 사용해 다른 멤버를 지정한 경우

프라이머리 서버 변경 우선순위

- 가장 낮은 MySQL 버전 기준으로 패치한다.
- 각 멤버의 가중치 값이 높은 순서대로
- UUID 사전식 순서대로 한다.

### 2.2.2 멀티 프라이머리 모드

모든 멤버가 프라이머리 서버로 쓰기가 발생한다. 가장 중요한 것은 멤버간 **버전 호환성**

그룹 참여 특이사항

- 그룹 내 가장 낮은 MySQL 버전보다 낮으면 안된다.
- MySQL 8.0.17 이상 서버가 합류할 때 버전 호환이 안되면, 읽기 서버가 된다.

## 2.3 그룹 멤버 관리

그룹 멤버에 대한 정보는 performance_schema의 replication_group_members 테이블에 있다.

- UUID, 포트, MySQL 버전, 멤버의 역할 등을 알 수 있다.
- MEMBER_STATE라는 컬럼이 있는데 이는 현재 그룹 멤버의 상태를 뜻한다.
    - ONLINE : 정상적으로 동작하고 있음
    - RECOVERING : 그룹에 참여하기 위해 데이터를 전달받고 있음
    - OFFLINE : 그룹 복제 플러그인이 로딩되어 있으나, 아직 복제에 참여하지 않음
    - ERROR : 그룹 복제에 소속되어 있으나, 정상적으로 복제가 이루어지지 않고있음
    - UNREACHABLE : 현재 통신이 불가능함

그룹 복제가 관리하는 멤버 목록과 상태 정보를 뷰라고도 하는데, 멤버가 변경될 수 있기 때문에 뷰는 특정 시점의 그룹 멤버 목록을 뜻한다.

따라서, 뷰에는 ID를 주어 변경된 시점을 식별할 수 있도록 한다. 뷰의 변경 기록은 View_change에 기록된다.

## 2.4 그룹 복제에서의 트랜잭션 처리

그룹 복제에서 트랜잭션은 “합의”와 “인증” 단계를 거친 뒤 적용된다.

- **합의 :** 그룹 내 일관적인 트랜잭션 적용을 위해 멤버들에게 트랜잭션 적용을 제안하고 승낙받는 과정
- **인증** : 전달받은 트랜잭션 WriteSet 이 충돌되는지 확인한다. (멀티 프라이머리 환경에서만 충돌 발생)

![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/85796588/e2772f80-0dee-4dd9-8cee-e152f675f631)

트랜잭션 복제 과정

1. 소스 서버에게 트랜잭션 요청 발생
2. 실행 한 뒤, 그룹 멤버에게 트랜잭션 적용 제안
3. 과반수 이상의 멤버에게 응답이 오면 인증 (트랜잭션 충돌 확인) 
4. 바이너리 로그 작성 후 커밋

### 2.4.1 트랜잭션 일관성 수준

각 멤버는 동일한 트랜잭션을 적용하지만, 실제 적용 시점은 상이하다. 그래서 아주 짧은 시간이지만, 멤버마다 값이 다를 수 있다.

하지만, MySQL 8.0.14 버전부터 그룹 복제에서 트랜잭션 일관성을 가져갈 수 있도록 변경되었다. (group_replication_consistency 변수)

- EVENTUAL : default로, 이전 버전과 동일
- BEFORE_ON_PRIMARY_FAILOVER : 싱글 프라이머리 모드에서 프라이머리 failover가 발생해 신규 프라이머리가 채택되었을 때, 기존의 트랜잭션이 적용될 때 까지 대기하게 된다.
    - 대기 시간을 지정할 수 있다.
    - 대기중에도 서버 모니터링을 위한 명령어는 실행이 가능하다. (SHOW, SET, DO, EMPTY, USE 등)
- BEFORE : 모든 선행 트랜잭션이 완료될 때 까지 대기 후 처리한다. (시간 제한이 있다)
- AFTER : 모든 멤버들이 커밋될 준비가 된 뒤 최종적으로 커밋된다. 모든 멤버가 동기화 된다. (느림)
- BEFORE_AND_AFTER : 모든 트랜잭션은 선행 트랜잭션이 적용될 때 까지 기다리고, 모든 멤버가 준비되면 그때 커밋된다. (모든 멤버가 동기화되며, 다른 트랜잭션을 기다린다)

### 2.4.2 흐름 제어

멤버간에 트랜잭션 적용 불균형으로 발생하는 문제를 방지하기 위해 멤버들의 쓰기 처리량을 조절하는 매커니즘이다. (group_replication_flow_control_mode 변수)

특징

- 흐름제어가 OFF된 멤버는 아예 제외하고 처리량을 조절한다.
- 인증, 적용, 트랜잭션 수 등을 수집하여 멤버끼리 공유한다. (group_replication_flow_control_period 통계 수집 초단위)
- 처리량 조절은 인증 큐 크기와 적용 큐 크기를 바탕으로 판단한다. (임계값 변수로 설정 가능)

장점

- 멤버간 트랜잭션 갭을 줄여준다.
- 트래픽 변화에도 빠르게 적응한다.

## 2.5 그룹 복제의 자동 장애 감지 및 대응

방법

1. 멤버간 주기적인 통신을 주고받으며 서로의 상태를 확인한다. 
2. 5초 이상 응답이 없다면 의심을 한다. (MySQL 8.0.20 전은 즉시 추방, 이후는 변수로 조절)
3. 과반수 이상 멤버에게 의심을 받으면 그룹에서 추방한다.
4. 추방된 멤버는 자동으로 재가입을 시도한다. (변수로 재가입 회수 조절)

etc

- 추방된 뒤 다른 멤버와 통신재개가 되는경우 추방된 것을 알게 된다. 이때 그룹이 달라졌으므로 새로운 뷰 ID를 갖는다.
- 추방된 뒤 다른 멤버와 통신이 안되면 추방된 것을 모르므로 스스로 그룹을 탈퇴하지 않는다. 일정 시간 이상 통신이 단절되면 스스로 탈퇴하도록 하는 변수가 있다.
- 그룹에서 탈퇴한 뒤 재가입을 더이상 할 수 없거나, 시도하지 않는경우 group_replication_exit_state_action에 해당하는 작업을 진행한다.
    - READ_ONLY : MySQL 서버를 수퍼 읽기 전용 모드로 변경한다. (권한이 있어도 읽기만 가능)
    - OFFLINE_MODE : 세션 요청을 끊고, super_read_only 상태가 된다.
    - ABORT_SERVER : MySQL 서버를 종료시킨다.

## 2.6 그룹 복제의 분산 복구

그룹에 새로 가입하거나, 재 가입한 멤버가 있을때 그 사이에 적용된 트랜잭션을 적용해야 참여할 수 있게 된다. 이를 분산 복구라고 한다.

### 2.6.1 분산 복구 방식

- 복제 채널의 릴레이 로그를 확인한 뒤 미처 적용되지 못하고 남아있는 트랜잭션 복구
- 가입한 멤버 릴레이 로그를 확인한 뒤 분산 복구 시작 (적절히 사용, 하이브리드 가능)
    - 바이너리 로그 복제 : 비동기 복제 기반으로,  멤버의 바이너리 로그에서 적용되지 않은 트랜잭션을 가져와 적용하는 방식
    - 원격 클론 복제 : Clone Plugin을 사용해서, 다른 그룹 멤버의 InnoDB의 모든 데이터와 메타데이터 스냅샷을 가져와 멤버를 재구축하는 방식이다.

### 2.6.2 분산 복구 프로세스

1. 로컬 복구 : 재 가입의 경우, 적용되지 않은 트랜잭션을 적용한다.
2. 글로벌 복구 : 기존 그룹 멤버에게 기증자 역할을 할 멤버를 선택해 누락된 트랜잭션을 가져와 적용한다. (기증자는 무작위로 선택한다)
3. 캐시 트랜잭션 적용 : 복구가 완료되면 캐싱해서 보관하고 있던 트랜잭션을 그룹에 참여한다.

![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/85796588/ebe84260-c335-4bc6-8d1d-0653f135ba76)

기존 그룹에 Member4가 들어올 때 상황

1. 기증자를 선별하고 복구작업을 시작한다.
2. 복구 작업동안 처리되는 트랜잭션은 캐싱된다.
3. 복구가 완료된 후 캐시를 적용한다.

## 2.6.3 분산 복구 설정

- group_replication_recovery_retry_count : 연결 시도 횟수
- group_replication_recovery_reconnect_interval : 연결 시도 간격
- group_replication_recovery_complete_at(TRANSACTION_CERTIFIED) : 가입한 멤버 ONLINE으로 표기

## 2.6.4 분산 복구 오류 처리

분산 복구중 에러가 나도 장애 감지 및 다시 시도하도록 매커니즘이 구현되어 있다.

- 기증자로 선택한 멤버의 연결이 정상적으로 이루어지지 않는 경우
- 바이너리 로그 복제 방식으로 복구를 진행하던중 레플리케이션I/O, SQL 스레드에서 문제가 발생한 경우
- 원격 클론 작업이 실패하거나 완료되기 전에 중단된 경우
- 복구 작업동안 기증자 멤버에서 그룹 복제가 중단된 경우

분산 복구가 진행하기 어려운 경우(가입 멤버는 그룹에서 떠난다)

- 연결 재시도 횟수가 모두 소진된 경우
- 가입멤버에 필요한 트랜잭션이 그룹멤버들의 바이너리로그에 존재하지 않는 경우 + 원격 클론 방식으로 복구가 안되는 경우
- 가입 멤버가 그룹에서 존재하지 않는 트랜잭션을 가지고 있는 경우 + 바이너리 로그 방식으로 복구 하는 경우
- 가입 멤버가 전체 그룹 멤버에 대해 원격 클론 방식과 바이너리 로그 복제 방식 모두 안되는 경우
- 복구 작업이 진행되는 중에 가입 멤버에서 그룹 복제가 중다뇐 경우

## 2.7 그룹 복제 요구사항

- InnoDB 스토리지 엔진 사용
- 모든 테이블 PK 사용
- 그룹 멤버간 서로 원활한 통신이 되는 네트워크 환경
- 바이너리 로그 활성화 + ROW 형태의 바이너리 로그 포맷 사용 + 바이너리 로그 체크섬 설정
- log_slave_updates 활성화 - 모든 멤버가 primary 가 될 수 있음
- GTID 사용
- 고유한 server_id
- 복제 메타데이터 저장소 TABLE로 설정
- 트랜잭션 WriteSet이 수집되도록 설정
- 테이블 스페이스 암호화 모두 동일하게 설정
- lower_case_table_names 모두 동일하게 설정
- 멀티 스레드 복제 사용 설정

## 2.8 그룹 복제 제약 사항

- GTID의 제약사항
- 갭 락을 발생시킨 트랜잭션은 실행된 멤버에서만 유효하다. (공유 안됨)
- 테이블 락, 네임드 락 공유 안됨, 복제시 고려 안함
- 바이너리 로그 체크섬 기능은 MySQL 8.0.21 이상부터
- 멀티 프라이머리 멤버는 SERIALIZBLE 사용 불가
- 멀티 프라이머리 멤버는 동시에 서로 다른 멤버에게 DDL, DML 사용 불가
- 멀티 프라이머리 멤버는 FK + CASCADE 포함된 테이블 지원 불가.
- 멀티 프라이머리 모드에서 SELECT … FOR UPDATE 데드락 유발
- 그룹 복제 필터 기능 사용 불가
- 최대 9대 까지만 구성 가능

# 3. 셸

셸은 MySQL을 위한 고급 클라이언트 툴로 mysql보다 더 확장된 기능을 제공한다. 

- js, python 지원
    - session, dba, cluster, rs, db, shell, util API 사용 가능
- 관계형 데이터와 문서형 데이터를 모두 처리할 수 있다.
- InnoDB 클러스터 및 레플리카셋을 구축하는 API가 있다.

# 4. MySQL 라우터

InnoDB 클러스터에서 애플리케이션 서버로 유입된 쿼리 요청 적절한 MySQL 서버로 전달하고, 반환된 결과를 애플리케이션 서버에 전달하는 프록시 역할을 한다.

MySQL 라우터의 역할

- 구성 변경 자동 감지
- 쿼리 부하 분산
- 자동 failover

InnoDB 클러스터를 사용한다고 해서 모든 애플리케이션이 라우터로 접근하는 것은 아니다. 서버로 직접 접근하는 경우도 있다.

- 라우터로 접근하는 경우 : 구성이 변경되어도 자동감지되어 변경할 것이 없다.
- 직접 접근하는 경우 : 구성이 변경되면 변경 작업을 해야한다.

# 5.  InnoDB 클러스터 구축

## 5.1 InnoDB 클러스터 요구사항

- 버전
    - MySQL 서버 5.7.17 이상
    - MySQL 셸 1.0.8 이상
    - MySQL 라우터 2.1.2 이상
- 각 서버 Performance 스키마 활성화
- MySQL이 설치된 서버에 파이썬 2.7 이상

## 5.2 InnoDB 클러스터 생성

### 5.2.1 사전 준비

1. 각 서버에 MySQL을 설정하고 server_id를 만들어 둔다.
2. 서버중 한 대에서 MySQL 셸을 설치한 뒤 접속한다.
    1. 다음 명령어를 실행한다. `dba.configureInstance("계정@IP:포트")`
    2. DB 계정과 패스워드를 입력한다. (새로 생서앻도 좋다)

### 5.2.2 InnoDB 클러스터 생성

1. 셸을 통해 MySQL 서버중 한 대에 접속한다. (위에서 만든 계정 사용)
2. 다음 명령어로 클러스터를 생성한다 `dba.createCluster()` (메타데이터 설정, 그룹복제, 분산복구 계정생성까지 해준다)
3. 원하는 옵션을 설정한다. (기본은 싱글 프라이머리 모드다)

### 5.2.3 InnoDB 클러스터 인스턴스 추가

1. `Cluster.addInstance()` 명령어로 클러스터에 서버를 추가한다. (알아서 동기화 및 분산복구 실행)

### 5.2.4 MySQL 라우터 설정

1. 라우터용 서버를 만들고, 설치한다.
2. 다음 명령어를 통해 라우터를 부트스트랩한다 `mysqlrouter --bootstrap 클러스터계정@서버ID:포트 --name 라우터 이름 --directory 파일 저장 경로 --account 계정 --user 유저이름`
    1. bootstrap : 접속할 MySQL 서버 정보
    2. name : 라우터 이름
    3. directory : 부트스트랩 시 생성되는 디렉터리 및 파일 저장 경로
    4. user : 실행할 시스템 사용자 계정
3. 연결이 완료되면 MySQL 프로토콜로 연결되는 읽기 포트와 읽기/쓰기 포트, X프로토콜로 연결되는 읽기 포트와 읽기/쓰기 포트 총 4개가 생성된다.
4. metadata_cache와 routing 관련 설정을 한다.
    1. metadata_cache.ttl : 클러스터 메타데이터를 갱신하는 주기
    2. metadata_cache.use_gr_notifications : 클러스터의 그룹 복제에서 발생하는 변경 사항에 대해 MySQL 라우터가 알림을 받을 수 있다. 알림이 오면 메타데이터를 갱신한다.
    3. routing.destinations : 라우터에서 쿼리 요청을 전달할 MySQL 서버를 지정하는 옵션이다. (IP, URI 사용 가능)
    4. routing.routing_straegy : 라우터가  쿼리 요청을 할 MySQL 서버를 찾는 방법(rr등 많다)
    

# 6. InnoDB 클러스터 모니터링

MySQL셸에서 클러스터에 대한 모니터링을 할 수 있다.

- Cluster.describe() : 복제 토폴로지 구성 (간략하게)
- Cluster.status() : 클러스터의 전반적인 상태 (인자로 “extended:숫자”를 넣으면 자세하게)
    - 0 : 디폴트로 추가 정보가 없다.
    - 1: 클러스터의 그룹 복제 통신 프로토콜 버전, 그룹 이름, 각 클러스터 인스턴스들의 그룹 복제에서의 역할 및 상태 차단 시스템 목록과 클러스터 메타데이터 스키마 버전이 추가
    - 각 클러스터 인스턴스에서 처리된 트랜잭션에 대한 통계 정보 추가
    - 각 클러스터 인스턴스의 복제 커넥션 및 복제 처리 스레드에 대한 통계 정보 추가

# 7. InnoDB 클러스터 작업

## 7.1 클러스터 모드 변경

MySQL 8.0.14 부턴 무중단 변경이 가능하다.

- Cluster.switchToMultiPrimaryMode() : 클러스터를 멀티 프라이머리 모드로 전환
- Cluster.switchToSinglePrimaryMode(인스턴스) : 클러스터를 싱글 프라이머리 모드로 전환 (인자가 프라이머리)

## 7.2 프라이머리 변경

- Cluster.setPrimaryInstance(인스턴스) : 인자를 프라이머리로 만든다.

## 7.3 인스턴스 제거

- Cluster.removeInstance(인스턴스) : 인자를 클러스터에서 제거한다. (제거된 서버에서의 데이터는 남아있음)
    - 제거 대상 서버에 아직 적용되지 않은 트랜잭션은 `dba.gtidWaitTimeout` 동안 적용된다.
    - 제거 명령에 force:true를 추가하면 시간 초과된 트랜잭션은 무시된다. (그룹 참여에 제한이 생길 수 있다)

## 7.4 클러스터 해체

- Cluster.dissolve() : 클러스터 해체, 메타데이터 및 계정 삭제, 그룹 복제 중단. 단, 데이터는 유지된다.
    - 아직 적용되지 않은 트랜잭션은 `dba.gtidWaitTimeout` 동안 적용된다.
    - 제거 명령에 force:true를 추가하면 시간 초과된 트랜잭션은 무시된다. (그룹 참여에 제한이 생길 수 있다)

## 7.5 클러스터 및 인스턴스 설정 변경

- Cluster.options() : 클러스터 및 인스턴스 설정을 JSON 포맷으로 출력한다.
    - all:true을 추가하면 각 인스턴스의 그룹 복제와 관련된 전체 설정을 출력한다.
- Cluster.setOptions(option, value) : 클러스터 설정을 변경한다. (제한 있음)
    - tag
    - clusterName
    - exitStateAction
    - memberWeight
    - consistency
    - expelTimeout
    - autoRejoinTries
    - disableClone
- Cluster.setInstanceOption(instance, option, vlaue) : 인스턴스 설정을 변경한다. (제한 있음)
    - tag
    - exitStateAction
    - memberWeight
    - autoRejoinTries
    - label

### 7.5.1 빌트인 태그

MySQL 8.0.21 버전 부터 사용자 태그를 설정할 수 있다 (Key-Value) (키는 _로 시작할 수 없다.)

_로 시작하는건 미리 정의된 태그(빌트인 태그)를 뜻한다.

종류

- _hidden : true로 되어있으면 MySQL 라우터에서 해당 인스턴스로 쿼리를 전달하지 않는다.
- *disconnect*existing_sessions_when_hidden : true면서 hidden값도 true이면 MySQL 라우터는 해당 인스턴스의 연결을 끊는다.

사용 사례

- 인스턴스를 순차적으로 업그레이드 할 때
- 복제 지연이 발생할때
- 백업이나 분석용 서버일 때

# 8. InnoDB 클러스터 트러블슈팅

## 8.1 클러스터 인스턴스 장애

1. 한 인스턴스가 연결이 expelTimeout 만큼 끊기면 투표를 한다. 이때 과반수가 넘어가면 클러스터에서 추방한다.
2. 통신이 회복되면 autoRejoinTries만큼 재연결을 시도한다.
3. 그룹에서 완전히 제외되면 exitStateAction을 수행한다.
4. 새로 등록되거나 재등록 되는 인스턴스는 super_read_only 등 클러스터에 참여하는데 필요한 설정 후 그룹 복제를 실행한다.

## 8.2 클러스터의 정족수 손실

클러스터 과반수 이상의 인스턴스에 장애가 발생한 경우 과반수 이상의 동의가 필요한 작업은 불가능해 진다.

- 쓰기 요청 처리 불가
- 토폴로지 변경 불가

이런 경우 사용자가 개입해 클러스터를 정상적으로 돌려주어야 한다.

Cluster.forceQuorumUsingPartitionOf(인스턴스) 메서드를 사용해 클러스터를 강제로 재구성할 수 있다.

이 메서드는 클러스터에서 정상적인 인스턴스만 찾아서 재구성해준다.

# 9. InnoDB 클러스터 버전 업그레이드

클러스터 업그레이드는 다음과 같은 순서를 권장한다.

1. MySQL 라우터 업그레이드
2. MySQL 셸 및 InnoDB 클러스터 메타데이터 스키마 업그레이드
3. MySQL 인스턴스 업그레이드

MySQL 라우터를 업그레이드 하고, 셸을 업그레이드 한다.

셸을 업그레이드 한 뒤 각 인스턴스에 접속해 `dba.upgradeMetadata()` 메서드를 통해 손쉽게 스키마 버전을 업그레이드 할 수 있다.

다음으로 인스턴스를 업그레이드 할 때 _hidden 태그를 통해 하나씩 업그레이드 하면 된다.

# 10. InnoDB 클러스터 제약 사항

- InnoDB 클러스터 인스턴스에는 —defaults-extra-file 옵션을 사용해 추가적인 옵션 파일을 지정해 사용할 수 없다.
- InnoDB 클러스터는 인스턴스에 수동으로 구성된 별도의 복제 채널을 관리하지 않는다.
- InnoDB 클러스터는 샤딩을 지원하지 않으며, MySQL 라우터는 하나의 클러스터에 대해서만 설정 가능하다.
