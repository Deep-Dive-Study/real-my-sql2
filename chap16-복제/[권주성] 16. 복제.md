# 16. 복제

## 16.1 개요
#### 복제
- 복제란 `한 서버에서 다른 서버로 데이터가 동기화되는 것`

- **`소스 서버`** 는 원본 데이터를 가진 서버이고, **`레플리카 서버`** 는 복제된 데이터를 가지는 서버

- 레플리카 서버에서는 변경내역을 소스 서버로부터 전달받아서 자신이 가지고 있는 데이터에 반영함
  → 소스 서버에 저장된 데이터와 동기화됨

#### 레플리카 서버를 구축하는 목적
- **`스케일 아웃`**
    - DB 서버로 유입되는 트래픽도 자연히 증가해 DB 서버의 부하가 높아질 수 있음
    - 서버의 사양을 업그레이드한다 하더라도 한 대에서 처리할 수 있는 양에는 한계가 있음
    - 스케일 아웃은 스케일 업 방식보다 갑자기 늘어나는 트래픽을 대응하는 데 훨씬 더 유연

- **`데이터 백업`**
    - DB 서버에 저장된 데이터들을 주기적으로 백업하는 것이 필수적임
    - 백업이 실행되는 경우 백업 프로그램과 DBMS가 서버의 자원을 공유해서 사용하기 때문에 백업으로 인해 DBMS에서 실행중인 쿼리들이 영향을 받을 수 있음
        - 심각한 경우에는 쿼리의 처리 속도가 느려져 서비스에 문제가 발생할 수 있음
    - 이 같은 문제를 방지하기 위해 주로 복제를 사용해 레플리카 서버를 구축하고 데이터 백업은 레플리카 서버에서 실행함

- **`데이터 분석`**
    - 분석용 쿼리는 대량의 데이터를 조회하는 경우가 많고, 또 집계 연산을 하는 등 쿼리 자체가 굉장히 복잡하고 무거운 경우가 대부분
    - 복제를 사용해 분석용 쿼리만 전용으로 실행될 수 있는 환경을 만드는 것이 좋음

- **`데이터의 지리적 분산`**
    - DB 서버와 어플리케이션 서버가 서로 떨어져있는 경우 두 서버 간의 통신 시간은 떨어진 거리만큼 비례해서 늘어남
    - 복제를 사용해 어플리케이션 서버가 위치한 곳에 기존 DB 서버에 대한 레플리카 서버를 새로 구축해 사용함으로써 응답 속도를 개선할 수 있음

## 16.2 복제 아키텍처

- MySQL 서버에서 발생하는 모든 변경 사항은 **`바이너리 로그`** 에 순서대로 기록됨
- MySQL 복제는 이 **`바이너리 로그`를 기반** 으로 구현됨
- 소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되면, 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장하여(릴레이 로그) 자신이 가진 데이터에 반영함으로써 소스 서버와 레플리카 서버간에 데이터 동기화가 이뤄짐

#### 복제 동기화 과정과 스레드
- MySQL의 복제는 세 개의 스레드에 의해 작동함
    
    ![CleanShot 2024-01-09 at 22 14 57](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/a93aef31-b334-4a18-9d09-d1638f41f2bf)
    
- **`바이너리 로그 덤프 스레드`**
    - 레플리카 서버는 데이터 동기화를 위해 소스 서버에 접속해 **바이너리 로그 정보를 요청**
    - 소스 서버에서는 레플리카 서버가 연결될 때, 내부적으로 바이너리 로그 덤프 스레드를 생성해서 바이너리 로그의 내용을 레플리카 서버로 전송
    - 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행하며, 이벤트를 읽고난 후에는 바로 잠금을 해제함

- **`레플리케이션 I/O 스레드`**
    - 복제가 시작되면 레플리카 서버는 I/O 스레드를 생성하고, 복제가 멈추면 I/O스레드는 종료됨
    - I/O 스레드는 바이너리 로그 덤프 스레드로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 파일(릴레이 로그)로 저장

- **`레플리케이션 SQL 스레드`**
    - 레플리케이션 SQL 스레드는 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행

- I/O 스레드와 SQL 스레드는 **서로 독립적으로 동작**

#### 복제 관련 데이터
- 복제가 시작되면 레플리카 서버는 총 세 가지 유형의 복제 관련 데이터를 생성하고 관리함

- **`릴레이 로그`**
    - 레플리케이션 I/O 스레드에 의해 작성되는 파일
    - 소스 서버의 바이너리 로그에서 읽어온 이벤트 정보가 저장됨

- **`커넥션 메타데이터`**
    - 레플리케이션 I/O 스레드에서 소스 서버에 연결할 때 사용하는 DB 계정 정보 및 현재 읽고 있는 소스 서버의 바이너리 파일명과 파일 내 위치 값 등이 담겨있음
    - 시스템 변수인 `master_info_repository`를 통해 어떤 형태로 데이터를 관리할 지 설정할 수 있음
        - MySQL 8.0.2버전부터 기본값이 `TABLE`로 변경되었음 (`FILE` 타입은 향후 버전에서 제거될 예정)
        - 기본적으로 `mysql.slave_master_info` 테이블에 저장됨

- **`어플라이어 메타데이터`**
    - 어플라이어란? 레플리케이션 SQL 스레드에서 릴레이 로그에 저장된 소스 서버의 이벤트들을 레플리카 서버에 적용하는 컴포넌트
    - 어플라이어 메타데이터는 최근 적용된 이벤트에 대해 해당 이벤트가 저장돼있는 릴레이 로그 파일명과 파일 내 위치 정보 등을 담고있음
    - 레플리케이션 SQL 스레드는 이 정보들을 바탕으로 레플리카 서버에 나머지 이벤트들을 적용함
    - 커넥션 메타데이터와 마찬가지로 `relay_log_info_repository`시스템 변수를 통해 어떤 형태로 데이터를 관리할 지 설정할 수 있음
        - 기본값이 `TABLE`이기 때문에, 기본적으로 `mysql.slave_relay_log_info` 테이블에 저장됨

## 16.3 복제 타입

#### MySQL의 복제 방식
- **`바이너리 로그 파일 위치기반 복제`**

- **`글로벌 트랜잭션 id기반 복제`**

### 16.3.1 바이너리 로그 파일 위치기반 복제
- 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태
- 레플리카 서버는 소스 서버의 어느 이벤트까지 로컬 디스크로 가져왔고 또 적용했는지에 대한 정보를 관리하는데, 이 정보를 소스 서버에 전달하면 그 이후의 바이너리 로그 이벤트들을 가져옴
    - 이러한 이벤트 하나하나를 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치값(offset)의 조합으로 식별
- 주의할 점
    - 복제의 구성원이 되는 모든 MySQL 서버가 고유한 **`server_id`** 값을 갖도록 해야함
    - 바이너리 로그에는 각 이벤트별로 이벤트가 최초로 발생한 MySQL 서버를 식별하기 위해 MySQL 서버의 **`server_id` 값을 함께 저장**
      - **기본 값은 1**
    - 레플리카 서버에 설정된 server_id와 바이너리 로그 파일에 기록된 이벤트의 server_id가 같으면, 레플리카 서버에서는 해당 이벤트를 적용하지 않고 무시함
      - 따라서, **복제에 참여한 MySQL 서버들이 모두 고유한 `server_id`값을 가지고 있어야 함**

**과정**

- 설정 준비 → 복제 계정 준비 → 데이터 복사 → 복제 시작

1. 설정 준비
    - 소스 서버 설정
        - 기본적으로 MySQL 복제를 사용하려면 **`소스 서버에서 반드시 바이너리 로그가 활성화`** 돼있어야 함 (기본값 → 활성화)
        
          ![CleanShot 2024-01-09 at 22 26 33](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/be365f0e-1624-4ee3-8b81-92d1dc9fd5ac)

    - 레플리카 서버 설정
        - 각 MySQL 서버가 고유한 server_id 값을 가져야 함
        - 레플리카 서버는 읽기 전용으로 사용되므로 **`read_only`** 설정도 함께 사용할 수 있음
        - 소스 서버의 장애로 레플리카 서버가 소스 서버로 승격될 수 있음을 고려한다면, `log_slave_updates` 시스템 변수도 명시함
            - **기본적으로** 레플리카 서버는 복제에 의한 데이터 변경 사항은 자신의 바이너리 로그에 기록하지 않음
            - `log_slave_updates` 시스템 변수를 설정하면 복제에 의한 데이터 변경 내용도 자신의 바이너리 로그에 기록하게 됨
        
          ![CleanShot 2024-01-09 at 22 27 34](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/44b3503e-d0ba-4c44-9350-38f99a6e5077)

          ![CleanShot 2024-01-09 at 22 27 42](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/1c2558bf-8af5-425a-8765-a1c13d48958a)

        
2. 복제 계정 준비
    - 레플리카 서버가 사용할 계정을 `복제용 계정`이라고 함
    - 복제에서 사용되는 계정의 비밀번호는 레플리카 서버의 커넥션 메타데이터에 평문으로 저장됨
    - 따라서, 보안상 복제에 사용되는 권한만 주어진 별도의 계정을 생성해 사용하는 것이 좋음
    - 이 계정은 반드시 **`REPLICATION SLAVE`** 권한을 가지고 있어야 함

      ![CleanShot 2024-01-09 at 22 51 40](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/5ea52796-2e04-4c58-a8b4-1011af0c3922)

3. 데이터 복사
    - 소스 서버의 데이터를 레플리카 서버로 가져와서 적재해야 함
    - MySQL 엔터프라이즈 백업이나 `mysqldump` 등과 같은 툴을 이용해 소스 서버에서 데이터를 내려받아 레플리카 서버로 복사하면 됨
    - 자세한 내용은 책을 참고하자
                
4. 복제 시작
    - 레플리카 서버에 데이터 적재가 완료된 시점에는 이미 소스 서버의 데이터의 시점보다 훨씬 지연된 상태
        
        ![CleanShot 2024-01-09 at 22 28 51](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/9e01bafe-43bf-44d9-be2e-b43f2daecdfe)
        
    - 복제를 설정하는 명령은 `CHANGE REPLICATION SOURCE TO` (또는 CHANGE MASTER TO) 명령으로, mysqldump로 백업받은 파일의 헤더부분에서 해당 명령어를 참조할 수 있음
        
        ```bash
        -- CHANGE REPLICATION SOURCE TO MASTER_LOG_FILE='binary-log.000002', MASTER_LOG_POS=2708;
        ```
        
    - 소스 서버의 MySQL 서버의 호스트명, 포트, 복제용 사용자 계정, 비밀번호 등을 추가하여 복제 설정 명령을 준비
        
      ![CleanShot 2024-01-09 at 22 55 45](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/3ac56b7a-408a-4be0-b65d-38ebfa3d2853)

    - `SHOW REPLICA STATUS` 명령을 실행해 보면 복제 관련 정보가 레플리카 서버 MySQL에 등록돼있음
    - 복제 관련 정보가 **`등록만 된 것이지`**, 동기화가 시작된 것은 아님
        - Replica_IO_Running, Replica_SQL_Running이 **No**로 되어있음
    - **`START REPLICA`** 명령
        - 데이터 변경사항들을 소스 서버로부터 가져와 적용하게 됨
      
#### 16.3.1.2 바이너리 로그 파일 위치기반의 복제에서 트랜잭션 건너뛰기
- 종종 레플리카 서버에서 소스 서버로부터 넘어온 트랜잭션이 제대로 실행되지 못하고 에러가 발생해 복제가 멈추는 현상이 발생함
- 심각한 문제인 경우 레플리카 서버의 데이터를 모두 버리고 처음부터 다시 레플리카 서버를 구축한 뒤 복제를 다시 구성해야 할 수도 있음
- 하지만 경우에 따라 레플리카 서버에서 문제되는 소스 서버의 트랜잭션을 무시하고 넘어가도록 처리해도 괜찮을 때가 있음
- 이는 `sql_slave_skip_counter` 시스템 변수로 설정할 수 있음
    - `sql_slave_skip_counter`가 1이면, 로그 이벤트 1개를 무시하는 것이 아니라 현재 이벤트를 포함한 **이벤트 그룹을 무시하는 것**
    - 하나의 트랜잭션에 여러 개의 DML 쿼리들이 포함되는 경우가 존재한다면, 에러가 발생한 쿼리 외에 다른 쿼리들이 예상치 못하게 함께 무시될 수 있으니 주의해서 사용해야 함

### 16.3.2 글로벌 트랜잭션 아이디 기반 복제
- 로그 파일 위치기반 복제 방식의 문제점
    - 로그 파일 위치기반 복제 방식은 각각의 이벤트들이 바이너리 로그 파일명과 파일 내 위치 값의 조합으로 **식별** 함
        - 문제는, 이 식별이 **소스 서버에서만 유효하다**는 것
        - 동일한 이벤트가 레플리카 서버에서 동일한 파일명 + 동일한 위치에 저장된다는 보장이 없음
        - 한마디로 복제에 투입된 서버들마다 동일한 이벤트에 대해 서로 다른 값을 갖게 될 수 있음
    
    - 복제를 구성하는 서버들이 서로 호환되지 않는 정보를 이용해 복제를 진행함으로써 복제의 토폴로지를 변경하는 작업이 때로 거의 불가능할 때가 많음
        - 토폴로지 변경이 어렵다는 것은 → 그만큼 복제를 이용한 장애 복구가 어렵다는 뜻
  
##### 16.3.2.1 GTID의 필요성

  ![CleanShot 2024-01-09 at 22 31 02](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/ea42b142-570b-4102-9161-393c82084676)

  ![CleanShot 2024-01-09 at 22 31 14](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/1c3645f1-df2d-4c0a-827a-b691ff09ae9f)
    
  - 서버의 바이너리 로그 파일명이 무엇인지, 바이너리 로그 파일에서 어느 위치부터 이벤트를 가져와야 하는지 입력할 필요가 없다
  - GTID가 “af99Sd80-939e-lleb-bb37-ba122a9a8ae3:98”이었던 트랜잭션은 B,C 서버에서도 “af99Sd80-939e-lleb-bb37-ba122a9a8ae3:98”이다
  - C 서버는 현재 B 서버로 복제를 다시 연결할 때도 B 서버에서 동일한 GTID 이후의 바이너리 로그 이벤트를 가져와서 동기화하면 된다
  - C 서버는 새로운 소스 서버인 B동기화할 수 있도록 준비되면 이제 클라이언트의 쿼리 요청을 B 서버와 C서버로 나눠서 실행할 수 있게 하면 된다

##### 16.3.2.2 글로벌 트랜잭션 아이디
- GTID는 서버에서 커밋된 각 트랜잭션과 연결된 고유 식별자

- 해당 트랜잭션이 발생한 서버에서 고유할 뿐만 아니라, 그 서버가 속한 복제 토폴로지 내 모든 서버에서 고유함

- GTID는 바이너리 로그에 기록된 **커밋된 트랜잭션에 한해서만 할당** 됨
    - 데이터 읽기만 수행하는 SELECT 쿼리나, sql_log_bin 설정이 비활성화돼있는 상태에서 발생한 트랜잭션은 바이너리에 기록되지 않기 때문에, GTID가 할당되지 않음

- GTID는 ‘소스 아이디’와 ‘트랜잭션 아이디’ 값의 조합으로 생성됨

  ![CleanShot 2024-01-09 at 22 44 58](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/46c83f04-f096-4b05-a211-3c3422bf5d7b)
    
    - 소스 아이디 : MySQL 서버의 `server_uuid` 시스템 변수 값
        - `server_uuid`는 MySQL 서버가 시작되면서 자동으로 부여됨
      
        - MySQL 서버를 시작할 때 데이터 디렉터리에 auto.cnf라는 파일이 생성되는데 그 안에 server_uuid 값이 저장되어 있음
            - auto.cnf 파일은 삭제되더라도 자동으로 다시 생성됨
            - 다만, auto.cnf 파일에 저장돼있는 UUID값은 복제가 설정된 소스 서버와 레플리카 서버의 GTID값에 사용되고 있는 값이므로 삭제되지 않도록 주의하는게 좋음
  
    - 트랜잭션 아이디 → 서버에서 커밋된 트랜잭션 순서대로 부여되는 값 (1부터 1씩 단조 증가)

- 현재 사용되는 GTID 확인하기
    - mysql 데이터베이스 내의 “gtid_executed” 테이블을 조회하거나 `gtid_executed` 시스템 변수를 통해 확인할 수 있음
    - GTID는 각각의 값이 하나씩 개별로 보여지거나 연속된 값들인 경우 범위로 보여질 수 있으며 이 밖에도 다양한 형태가 있음
        
      ```bash
      af99Sd80-939e-lleb-bb37-ba122a9a8ae3:1-5:18:99-103
      ```
        
    - 하나 이상의 GTID 값으로 구성돼있는 것을 **‘GTID 셋’** 이라 함
    - GTID 셋에는 서로 다른 UUID를 가지는 GTID 값들도 포함될 수 있음
        
      ```bash
      af99Sd80-939e-lleb-bb37-ba122a9a8ae3:1-5:18:99-103,llebbb37-Sd80-9eae-a9a8-ba12293lleb3:1-3
      ```
        
##### 16.3.2.3 글로벌 트랜잭션 아이디 기반의 복제 구축
- MySQL 서버에서 GTID를 활성화하는 것과 GTID 기반 복제를 사용하는 것은 **별개**
- GTID 활성화는 GTID 복제를 위한 하나의 조건일 뿐, 활성화돼있다 하더라도 복제는 바이너리 로그 파일 위치 기반의 복제를 사용할수도 있음

1. 설정 준비
    - GTID 기반의 복제를 사용하려면 복제에 참여하는 모든 MySQL 서버들이 GTID가 활성화돼있어야 함
    
    - 각 서버의 `server_id` 및 `server_uuid`가 복제 그룹 내에서 고유해야 함
    
    ![CleanShot 2024-01-09 at 22 34 49](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/7f03e65d-aded-49bb-9bd2-7e3f8e2af81a)

2. 복제 계정 준비

   ![CleanShot 2024-01-09 at 22 35 46](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/ac58573f-e19c-4eb6-b1e4-07cd2e934b23)

   - 위에 내용과 동일함

4. 데이터 복사
  - 소스 서버에서 아래 mysqldump 명령을 실행
        
    ![CleanShot 2024-01-09 at 22 36 10](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/31a6a43b-bc6e-4802-a54b-48b95bbe2198)
 
    - 데이터를 덤프받아 레플리카 서버를 구축하려는 경우, 덤프가 시작된 시점의 소스 서버 GTID 값을 레플리카 서버에서 다음 2개의 시스템 변수에 설정해야 복제를 시작할 수 있음
      - `gtid_executed` : MySQL 서버에서 실행되어 **바이너리 로그 파일에 기록된** 모든 트랜잭션들의 GTID 셋
      - `gtid_purged` : 현재 MySQL 서버의 **바이너리 로그 파일에 존재하지 않는** 모든 트랜잭션들의 GTID 셋

    - 레플리카 서버는 `gtid_executed` 값을 기반으로 다음 복제 이벤트를 소스 서버로부터 가져옴
        - `gtid_executed` 값은 읽기 전용이므로 사용자가 변경할 수 없음
        - `gtid_purged` 변수 값만 수정할 수 있음
        - 따라서, 소스 서버에서 데이터 덤프가 시작된 시점의 소스 서버의 GTID 값을 레플리카 서버의 `gtid_purged` 시스템 변수에 지정해 `gtid_executed` 시스템 변수에도 그 값이 설정되게 해야함

    - —set-gtid-purged 옵션
        - —set-gtid-purged 옵션은 덤프가 시작된 시점의 GTID가 덤프 파일에 기록되며 `sql_log_bin` 시스템 변수를 ‘비활성화’하는 구문도 함께 기록됨
            - 이는 덤프 파일을 실행할 때 적용되는 트랜잭션들이 레플리카 서버에서 새로운 GTID를 발급받는 것을 방지함
            - 즉, 레플리카 서버에서 덤프 파일을 적재하는 작업이 바이너리 로그에 기록되지 않으므로 GTID가 생성되지 않는 것임
        - 옵션값들
          ![CleanShot 2024-01-09 at 22 37 21](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/9c19752a-24e0-44db-8d12-c5784e7f9b0c)

    - mysqldump로 백업받은 데이터 파일을 레플리카 서버로 옮겨 적재하면, 레플리카 서버에서 gtid_executed와 gtid_purged 시스템 변수 값이 다음과 같이 자동으로 설정됨

      ![CleanShot 2024-01-09 at 22 38 32](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/01ad7b1b-7e10-49e6-93e1-c23b8a97efcb)

5. 복제 시작
    - 소스 서버와 레플리카 서버 간의 복제를 시작하는 명령으로, 소스 서버에서 백업 시점부터 지금까지 변경된 데이터와 이후 변경될 데이터를 실시간으로 가져와 적용함
    
      ![CleanShot 2024-01-09 at 22 40 46](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/6dae46be-c273-4a1f-8461-4538c4420bfc)
      
      - 바이너리 로그 파일 위치기반 복제와 다른 점
        - SOURCE_LOG_FILE와 SOURCE_LOG_POS가 없음
        - **SOURCE_AUTO_POSITION**가 있다
          → 이 옵션으로 인해 레플리카 서버는 자신의 `gtid_executed` 값을 참조해서 해당 시점부터 소스 서버와 복제를 연결해서 데이터를 동기화함

##### 16.3.2.4 글로벌 트랜잭션 아이디 기반 복제에서 트랜잭션 건너뛰기
- GTID를 사용하는 **복제 환경의 레플리카 서버에서는 더이상 `sql_slave_skip_counter` 시스템 변수를 사용할 수가 없음
    - GTID 기반 복제에서 레플리카 서버는 기본적으로 자신의 GTID 값과 소스 서버의 GTID 값을 비교해서 소스 서버의 변경 이벤트를 가져옴
    - 그렇기 때문에 레플리카 서버가 소스 서버의 GTID 값보다 더 적거나 더 많은 GTID 값을 가진 채로 복제를 계속 유지시킬 수는 없음
- 트랜잭션을 무시하고 싶다면 레플리카 서버에서 **수동으로** 빈 트랜잭션을 생성해 GTID 값을 만들어야 함
