# 13. 파티션
- **테이블이 `논리적으론 하나`이지만, `물리적으로 여러 테이블`로 분리** 해 관리할 수 있게 하는 기능
  - 주로 대용량 테이블을 물리적으로 분산하는 것이 목적
  - 하지만, 무조건 성능이 빨라지는 것은 아니기 때문에 주의해야 함
    - 어떤 쿼리를 사용하는 냐에 따라 오히려 성능 저하가 있을 수 있음

## 13.1 개요
### 13.1.1 파티션을 사용하는 이유
- 테이블이 너무 커서 **인덱스 크기가 물리적인 메모리보다 훨씬 크거나**, 데이터 특성상 **주기적인 삭제가 필요한 경우** 등의 경우

#### 13.1.1.1 단일 INSERT 와 단일 또는 범위 SELECT 의 빠른 처리
- 인덱스는 일반적으로 SELECT 를 위한 것이지만 UPDATE/DELETE 쿼리를 위해 필요한 경우도 많음
  - UPDATE/DELETE 처리를 위해 대상 레코드를 **검색** 해야 하기 때문에 인덱스가 필수적임

- 즉, 인덱스가 커질수록 SELECT 는 물론 UPDATE/DELETE 작업도 함께 느려진다는 것을 알아야함

- 인덱스의 **워킹셋 (Working Set)** 이 물리 메모리 보다 크다면 쿼리 처리성능은 상당히 느려질 것임
  `워킹셋 (Working Set)`
  - 전체데이터가 100만건이라고 해서 그 데이터가 모두 빈번하게 사용되는 것은 아님
  - 전체의 2~30% 가 대부분의 트래픽을 차지할 것
  - 이중 활발하게 사용되는 데이터를 **워킹셋** 이라고 함

  ![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/f7d6165e-de09-4fac-b567-bc8ee435ec0d)

- 한 테이블의 인덱스 크기가 물리적으로 MySQL이 사용가능한 메모리 공간보다 큰 경우와 파티션을 적용했을 때의 경우
  - 즉, 파티션을 하지않는다면, 인덱스도 커지고 그만큼 물리적인 **`메모리 공간`** 도 더 필요해짐

- 결론적으로 파티션은 **데이터와 인덱스를 조각화** 해 물리적 메모리를 효율적으로 사용할 수 있게 해줌

#### 13.1.1.2 데이터의 물리적인 저장소를 분리
- 데이터 파일이나 인덱스 파일의 크기가 크다면 백업이나 관리 차원에서 비용이 커짐
  - 테이블이나 인덱스를 파일 단위로 관리하는 MySQL에선 더욱 치명 

- 이를 위해 MySQL은 파티션을 통해 파일의 크기를 조절하거나, 파티션 별 파일들이 저장될 위치, 디스크를 구분해 지정하는 방법도 지원함

- 하지만, 테이블의 **파티션 별 인덱스를 생성하거나, 파티션 별 다른 인덱스를 가지는 방식을 지원하지 않음**
  - 인덱스가 적용되어 있다면 모든 파티션에 동일한 인덱스가 생성되며, 인덱스 컬럼은 동일해야 함 

#### 13.1.1.3 이력 데이터의 효율적인 관리
- 로그 데이터는 시간이 지나면 별도로 아카이빙 하거나, 백업 후 삭제하는 것이 일반적임

- 다른 데이터에 비해 라이프 사이클이 상당히 짧은 것이 특징

- 하지만, 로그 테이블에서 데이터를 삭제하거나 백업하는 작업은 일반적인 테이블에 비해 상당히 부하가 큼

- 이를 파티셔닝해 관리한다면 파티션 추가와 삭제를 통해서 상당히 빠르고 쉽게 해결할 수 있음

  ![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/f6ff5429-22ae-4bfd-9e0a-741a34021509)

### 13.1.2 MySQL 파티션의 내부 처리

```sql
CREATE TABLE tb_article(
    article_id INT NOT NULL,
    reg_date DATETIME NOT NULL,
    PRIMARY KEY (article_id, reg_date)
) PARTITION BY RANGE (YEAR(reg_date)) (
    PARTITION p2009 VALUES LESS THAN (2010),
    PARTITION p2010 VALUES LESS THAN (2011),
    PARTITION p2011 VALUES LESS THAN (2012),
    PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```
- `reg_date` 컬럼을 **파티션 키** 로 지정

- 이는 해당 레코드가 어느 파티션에 저장될지 결정하는 역할을 담당함 → 파티션 키

#### 13.1.2.1 파티션 테이블의 레코드 INSERT
- INSERT 쿼리 실행시 파티션 키의 값을 이용해 **파티션 표현식을 평가** 함

- 해당 결과를 이용해 저장될 적절한 파티션을 결정

- 파티션이 결정된 후, 나머지 과정은 일반 테이블과 동일한 처리과정으로 진행됨

![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/199fc094-c8c9-4071-9d5f-f0b9161c3893)

#### 13.1.2.2 파티션 테이블의 UPDATE
- UPDATE 쿼리를 실행하려면 해당 레코드가 **어느 파티션에 존재하는지** 찾아야 함

- WHERE 조건에 파티션 키 칼럼이 존재한다면, 해당 값을 이용해 **특정 파티션** 에서 검색 수행

- 하지만 파티션 키가 조건에 존재하지 않는다면 **모든 파티션** 을 검색해야 함

- 실제 레코드 변경작업 또한 UPDATE 쿼리가 어떤 컬럼을 변경하냐에 따라 처리가 달라짐
  - 파티션 키 컬럼을 변경한다면, 기존 파티션에서 해당 레코드를 삭제하고, 새로운 파티션에 새롭게 레코드를 저장 (DELETE & INSERT)
  - 파티션 키를 제외한 컬럼을 변경한다면 일반 테이블과 동일하게 처리

![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/4ef93636-515b-4ce2-938e-f7a8c7c2b1e7)

#### 13.1.2.3 파티션 테이블의 검색
- 파티션 테이블을 검색할때 **성능에 큰 영향을 미치는 조건**

  ![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/7e8d6de5-80c2-439f-a232-0177734ea4e9)

![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/20ada433-ca6a-464c-8443-87f4c5c6b870)

- 3/4번 방식은 가능하면 피하는 것이 좋음
  - 인덱스를 사용할 수 있는지가 더 중요
  - 파티션 키를 사용하지 않은 경우는 파티션 개수가 많을 수록 부하가 커지고 처리 시간도 늘어남

#### 13.1.2.4 파티션 테이블의 인덱스 스캔과 정렬
- MySQL 파티션 테이블의 인덱스는 모두 로컬 인덱스
  - 파티션과 관계없이 글로벌한 인덱스를 지원하지 않음

- 파티션 테이블의 인덱스의 특징은, 파티션 순서대로 정렬되어 있지 않다는 점
  - 일반적인 테이블이라면 인덱스 순서대로 읽을시 정렬되어 있음
  - 하지만 파티션 테이블의 경우 그렇지 않음에 유의할 것

  ![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/6b9aa49d-cbc2-46cd-936d-12ca7f8d2978)

- MySQL 은 여러 파티션에 대해 인덱스 스캔 수행시, 각 파티션으로 부터 조건에 일치하는 레코드를 순서대로 읽으며 **우선순위 큐** 에 임시로 저장함

- 그리고, 다시 필요한 순서대로 데이터를 가져옴 **(인덱스의 정렬 순서)** → Merge & Sort
  - 각 파티션에서 읽은 데이터가 이미 정렬된 상태라 가능한 것

- 파티션 테이블에서 인덱스 스캔을 통해 레코드를 읽을 때 MySQL 서버가 별도의 정렬 작업을 수행하지 않음

#### 13.1.2.5 파티션 프루닝
- 옵티마이저의 최적화 단계에서 필요한 파티션만 골라내고, 불필요한 것들은 제외하는 것을 **파티션 프루닝 (Partition pruning)** 이라고 함

- 파티션 프루닝 정보는 실행 계획을 떠보면 partitions 컬럼을 통해 알 수 있음

## 13.2 주의사항

#### 13.2.1 파티션의 제약 사항

![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/d17782a8-17a8-433f-b0d8-caa9aaa16975)

- 파티션 표현식에서 기본적인 산술연산자를 사용할 수 잇고, 다음 내장함수들을 사용할 수 있음

  ![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/a8120c47-812d-4288-abe0-64324c04a30d)

- 표현식에 사용가능하다고 해서, 모두 파티션 프루닝 기능을 지원하지 않으므로 주의할 것

### 13.2.2 파티션 사용시 주의사항
- 파티션의 목적은 **작업 범위를 줄이는 것** 

- 유니크 인덱스는 **중복 레코드에 대한 체크 작업** 때문에 범위가 좁혀지지 않음

#### 13.2.2.1 파티션과 유니크 키 (프라이머리 키 포함)
- 테이블에 유니크 인덱스 (PK 포함) 가 있다면 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 컬럼을 포함해야 함

- 예시는 책에서 확인하기

#### 13.2.2.2 파티션과 `open_files_limit` 시스템 변수
- MySQL은 일반적으로 테이블을 **파일 단위** 로 관리함
  - 때문에 동시에 오픈된 파일수가 많아질 수 있는데, 이를 제한하기 위한 `open_files_limit` 시스템 변수를 제공함

- 일반적인 테이블은 테이블당 오픈된 파일수가 2 ~ 3 개 수준

- 파티션 테이블의 경우 파티션 개수만큼 늘어남 (파티션 수 * 2 ~ 3)

- 쿼리가 적절히 파티션 프루닝으로 최적화 되었다고 해도, 동시에 **모든 파티션의 데이터 파일을 오픈** 해야함

- 때문에 파티션을 많이 사용한다면 위 옵션을 적절히 높은 값으로 조절해 주어야함

## 13.3 MySQL 파티션 종류
- 다른 DBMS 와 동일한 **기본 파티션 기법** 을 제공하고 있고, 해시와 키 파티션에 대해 추가적인 기법도 제공함
  - 레인지 파티션
  - 리스트 파티션
  - 해시 파티션
  - 키 파티션

### 13.3.1 레인지 파티션
- 파티션 키의 **연속된 범위** 로 파티션을 정의하는 방법
  - 가장 일반적으로 사용되는 파티션 방법

  ![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/799b6e5b-53a4-4bac-b1cc-4674bdfa134c)

#### 13.3.1.1 레인지 파티션의 용도
- 날짜를 기반 데이터가 누적되고, 연도나 월/일 단위로 분석 및 삭제해야할 때

- 범위 기반 데이터를 여러 파티션에 균등하게 나눌 수 있을 때

- 파티션 키 위주로 검색이 자주 실행될 때

- 레인지 파티션은 파티션의 두가지 장점 모두 취할 수 있음 
  - **`파티션의 장점`**
    - 큰 테이블을 작은 크기의 파티션으로 분리
    - **`필요한 파티션만 접근 (R/W)`** (중요)

### 13.3.2 리스트 파티션
- 리스트 파티션은 레인지 파티션과 매우 유사하게 동작함

- 큰 차이는 레인지 파티션은 **파티션 키의 범위** 로 구성하지만, 리스트 파티션은 **파티션 키 하나하나를 리스트로 나열** 함

- 때문에 MAXVALUE 와 같은 범위 지정이 불가능함

  ![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/4dfbd9c2-aa68-4178-af82-9a64ed2b4eb7)

  ![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/5dff65db-9163-47c5-b3c5-583586af4f27)


#### 13.3.2.1 리스트 파티션의 용도
- 파티션 키 값이 코드나 카테고리 처럼 고정적인 경우

- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야할 경우

- 파티션 키 값을 기준으로 레코드 건수가 균일하고, 검색 조건에 파티션 키가 자주 사용될 경우

### 13.3 해시 파티션

![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/75597db1-356e-436d-8c92-cf70b9a7222b)

![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/cb3848a7-ccd0-43a3-b1d1-661c70b17086)

- MySQL에서 정의한 해시 함수를 사용한 파티션 방법

- 이는 복잡한 알고리즘이 아닌, 파티션 표현식의 결과값을 파티션 개수로 나눈 나머지로 저장될 파티션을 결정하는 방법

- 때문에 파티션 키는 항상 정수 타입이거나 정수를 반환하는 표현식이어야 함

- 파티션 개수가 알고리즘과 연관되어 있기 때문에 파티션 추가/삭제 작업시 파티션 전체를 재분배하는 작업이 필요함

#### 13.3.3.1 해시 파티션의 용도
- 레인지/리스트 파티션으로 데이터를 균등하게 나누는것이 어려울 경우

- 테이블의 모든 레코드가 비슷한 사용빈도를 보이지만 테이블이 너무 커 파티션을 적용해야 하는 경우

- 대표적인 경우가 회원 테이블
 
#### 13.3.3.3.5 해시 파티션 주의사항
- 특정 파티션만 삭제하는 기능은 없음

- 파티션 추가의 경우 기존 모든 데이터의 재배치가 필요함

- 레인지나 리스트 파티션과 다른 방식으로 관리되므로 꼭 필요한지 확인이 필요함

- 일반적인 파티션 조작이나 특성은 대부분 리스트나 레인지 파티션임

- 해시나 키 파티션을 사용한다면 주의가 필요함

### 13.3.4 키 파티션

![image](https://github.com/Deep-Dive-Study/real-my-sql2/assets/99165624/6f5ff436-bfca-4179-a1c2-0564a0517913)

- 키 파티션은, 해시 파티션과 거의 비슷

- 키 파티션은 **해시 값의 계산도 MySQL 서버가 수행** 한다는 것이 차이점임

- 때문에 정수뿐 아닌 대부분의 데이터 타입에 사용할 수 있음

- `MD5()` 함수를 이용해 해시를 계산하고 `MOD` 연산을 이용해 파티션을 결정함

#### 13.3.4.2 키 파티션의 주의사항 및 특이사항
- 키파티션은 MySQL 서버가 `MD5()` 함수로 파티션하기 때문에 모든 타입에 대해 적용이 가능

- PK 나 유니크 키 중 일부만으로도 파티션이 가능

- 유니크 키를 파티션키로 사용한다면 반드시 NOT NULL 이어야 함

- 해시 파티션에 비해 레코드를 더 균등하게 분배할 수 있음

### 13.3.5 리니어 해시 파티션/리니어 키 파티션
- 해시/키 파티션의 경우 파티션 추가 병합시 전체 레코드의 재분배 작업이 필요함

- 이를 최소화 하기 위해 **리니어 (Linear)** 알고리즘이 공나된 것

- 각 레코드 분배를 위해 **Power of two (2의 승수)** 알고리즘을 이용함

- 이는 파티션 추가/병합시 다른 파티션에 미치는 영향을 최소화 함

#### 13.3.5.1 리니어 해시 파티션/리니어 키 파티션의 추가 및 통합
- Power of two 분배방식을 사용하기에 **특정 파티션의 데이터에 대해서만 이동 작업을 수행** 함

- 나머지 파티션들은 재분배 대상이 되지 않음

#### 13.3.5.1.3 리니어 해시 파티션/리니어 키 파티션과 관련된 주의사항
- Power of two 알고리즘을 사용하기 때문에 작업 범위를 최소화 하는대신, 각 파티션이 가지는 레코드 건수는 일반 해시/키 파티션에 비해 덜 균등해 질 수 있음

- 파티션 조정이 빈번하다면, 리니어 해시/키 파티션을, 조정이 필요없다면 해시/키 파티션을 사용하는 것이 좋음

### 13.3.6 파티션 테이블의 쿼리 성능
- 파티션 테이블의 쿼리 성능은 **얼마나 많은 파티션을 프루닝 할 수 있는가** 가 관건

- 테이블을 10개로 파티션해 10개 중 1 ~3 개만 주로 사용한다며 성능향상에 도움이 됨

- 하지만 10개로 나눠 10개를 균등하게 사용한다면 오히려 오버헤드만 심해지는 결과를 초례할 수 있음

- 이런 경우 샤딩을 적용할 경우 매우 효율적

- MySQL 서버 파티션은 샤딩이 아님

- 파티션 적용시 반드시 파티션 프루닝이 얼마나 도움이 될지 예측후 적용하자

- 레인지 파티션 이외의 파티션 적용시 파티션 프루닝을 더 많이 고민해 보아야 함
